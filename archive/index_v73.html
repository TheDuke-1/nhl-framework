<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NHL Championship Framework V7.3</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #0a0e17;
      --bg-secondary: #111827;
      --bg-card: #1a2234;
      --bg-hover: #243047;
      --text-primary: #f0f4f8;
      --text-secondary: #94a3b8;
      --text-muted: #64748b;
      --accent-elite: #10b981;
      --accent-contender: #3b82f6;
      --accent-bubble: #f59e0b;
      --accent-longshot: #ef4444;
      --accent-purple: #8b5cf6;
      --border-color: #2d3a4f;
      --glow-elite: rgba(16, 185, 129, 0.3);
      --glow-blue: rgba(59, 130, 246, 0.3);
    }

    body {
      font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
    }

    /* Animated background */
    .bg-pattern {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background:
        radial-gradient(ellipse at 20% 20%, rgba(16, 185, 129, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 80%, rgba(59, 130, 246, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(139, 92, 246, 0.05) 0%, transparent 70%);
      pointer-events: none;
      z-index: 0;
    }

    .container {
      position: relative;
      z-index: 1;
      max-width: 1500px;
      margin: 0 auto;
      padding: 24px;
    }

    /* Header */
    .header {
      text-align: center;
      margin-bottom: 32px;
      padding: 32px;
      background: linear-gradient(135deg, var(--bg-card) 0%, var(--bg-secondary) 100%);
      border-radius: 16px;
      border: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }

    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-elite), var(--accent-contender), var(--accent-purple));
    }

    .header h1 {
      font-size: 2.2rem;
      font-weight: 700;
      letter-spacing: -0.5px;
      margin-bottom: 8px;
      background: linear-gradient(135deg, var(--text-primary) 0%, var(--accent-elite) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .header .subtitle {
      color: var(--text-secondary);
      font-size: 0.85rem;
      margin-bottom: 4px;
    }

    .header .data-source {
      color: var(--text-muted);
      font-size: 0.75rem;
    }

    .header .data-source a {
      color: var(--accent-contender);
      text-decoration: none;
      transition: color 0.2s;
    }

    .header .data-source a:hover {
      color: var(--accent-elite);
    }

    /* Navigation */
    .nav {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .nav-btn {
      padding: 12px 24px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background: var(--bg-card);
      color: var(--text-secondary);
      font-family: inherit;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .nav-btn:hover {
      background: var(--bg-hover);
      color: var(--text-primary);
      transform: translateY(-1px);
    }

    .nav-btn.active {
      background: linear-gradient(135deg, var(--accent-contender), var(--accent-purple));
      color: white;
      border-color: transparent;
      box-shadow: 0 4px 12px var(--glow-blue);
    }

    /* Conference Filter */
    .conf-filter {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }

    .conf-btn {
      padding: 8px 20px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
      color: var(--text-muted);
      font-family: inherit;
      font-size: 0.8rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .conf-btn:hover {
      color: var(--text-secondary);
    }

    .conf-btn.active {
      background: var(--bg-hover);
      color: var(--text-primary);
      border-color: var(--accent-contender);
    }

    /* Tier Legend */
    .tier-legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .tier-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .tier-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .rank-legend {
      color: var(--text-muted);
      font-size: 0.7rem;
      margin-left: 12px;
    }

    .rank-legend .good { color: var(--accent-elite); }
    .rank-legend .ok { color: var(--accent-bubble); }
    .rank-legend .mid { color: var(--text-secondary); }
    .rank-legend .bad { color: var(--accent-longshot); }

    /* Matrix Table */
    .matrix-container {
      overflow-x: auto;
      border-radius: 12px;
      border: 1px solid var(--border-color);
      background: var(--bg-secondary);
    }

    .matrix-table {
      width: 100%;
      border-collapse: collapse;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.72rem;
    }

    .matrix-table th {
      padding: 10px 6px;
      text-align: center;
      background: var(--bg-card);
      color: var(--text-muted);
      font-weight: 600;
      font-size: 0.68rem;
      white-space: nowrap;
      border-bottom: 2px solid var(--border-color);
      position: sticky;
      top: 0;
    }

    .matrix-table th:first-child,
    .matrix-table th:nth-child(2) {
      text-align: left;
    }

    .matrix-table th .weight {
      display: block;
      font-weight: 400;
      color: var(--text-muted);
      font-size: 0.6rem;
      opacity: 0.7;
    }

    .matrix-table th.highlight {
      color: var(--accent-elite);
    }

    .matrix-table th.gsax-col {
      color: var(--accent-purple);
    }

    .matrix-table tbody tr {
      transition: background 0.15s;
    }

    .matrix-table tbody tr:nth-child(even) {
      background: rgba(26, 34, 52, 0.5);
    }

    .matrix-table tbody tr:hover {
      background: var(--bg-hover);
    }

    .matrix-table td {
      padding: 8px 6px;
      text-align: center;
      border-bottom: 1px solid rgba(45, 58, 79, 0.5);
    }

    .matrix-table td:first-child {
      font-weight: 600;
      color: var(--text-muted);
    }

    .team-cell {
      text-align: left !important;
    }

    .team-name {
      font-weight: 700;
      color: var(--text-primary);
      font-size: 0.85rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .injury-icon {
      color: var(--accent-longshot);
      font-size: 0.7rem;
      cursor: help;
    }

    .team-meta {
      color: var(--text-muted);
      font-size: 0.6rem;
      margin-top: 2px;
    }

    .score-cell {
      font-weight: 700;
      font-size: 1.1rem;
    }

    .score-adjustment {
      font-size: 0.6rem;
      color: var(--accent-longshot);
    }

    .stat-value {
      font-weight: 600;
      font-size: 0.78rem;
    }

    .stat-positive { color: var(--accent-elite); }
    .stat-negative { color: var(--accent-longshot); }
    .stat-neutral { color: var(--text-secondary); }
    .stat-gsax { color: var(--accent-purple); }

    /* Rank Badge */
    .rank-badge {
      display: inline-block;
      min-width: 22px;
      padding: 1px 4px;
      border-radius: 3px;
      font-size: 0.62rem;
      font-weight: 600;
      text-align: center;
      margin-top: 2px;
    }

    .rank-badge.rank-good {
      background: rgba(16, 185, 129, 0.25);
      color: #34d399;
    }

    .rank-badge.rank-ok {
      background: rgba(251, 191, 36, 0.2);
      color: #fbbf24;
    }

    .rank-badge.rank-mid {
      background: rgba(100, 116, 139, 0.2);
      color: #94a3b8;
    }

    .rank-badge.rank-bad {
      background: rgba(239, 68, 68, 0.2);
      color: #f87171;
    }

    /* Form Badge */
    .form-badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.62rem;
      font-weight: 600;
      text-transform: uppercase;
    }

    .form-blazing { background: rgba(251, 191, 36, 0.3); color: #fbbf24; border: 1px solid #fbbf24; }
    .form-hot { background: rgba(16, 185, 129, 0.2); color: var(--accent-elite); }
    .form-warm { background: rgba(52, 211, 153, 0.2); color: #34d399; }
    .form-stable { background: rgba(148, 163, 184, 0.2); color: var(--text-secondary); }
    .form-cold { background: rgba(245, 158, 11, 0.2); color: var(--accent-bubble); }
    .form-freezing { background: rgba(239, 68, 68, 0.2); color: var(--accent-longshot); }

    /* Tier indicator bar */
    .tier-bar {
      width: 3px;
      height: 100%;
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
    }

    tr[data-tier="elite"] { border-left: 3px solid var(--accent-elite); }
    tr[data-tier="contender"] { border-left: 3px solid var(--accent-contender); }
    tr[data-tier="bubble"] { border-left: 3px solid var(--accent-bubble); }
    tr[data-tier="longshot"] { border-left: 3px solid var(--accent-longshot); }

    /* Scatter Plot */
    .scatter-container {
      text-align: center;
    }

    .scatter-title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .scatter-subtitle {
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-bottom: 20px;
    }

    .scatter-svg {
      display: block;
      margin: 0 auto;
      background: var(--bg-card);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      background: var(--bg-card);
      border: 2px solid var(--accent-contender);
      border-radius: 10px;
      padding: 16px;
      min-width: 220px;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }

    .tooltip.visible {
      opacity: 1;
    }

    .tooltip-name {
      font-weight: 700;
      font-size: 1rem;
      margin-bottom: 6px;
    }

    .tooltip-grid {
      display: grid;
      gap: 4px;
      font-size: 0.78rem;
      margin-top: 10px;
    }

    .tooltip-row {
      display: flex;
      justify-content: space-between;
    }

    .tooltip-label {
      color: var(--text-secondary);
    }

    .tooltip-value {
      font-weight: 600;
    }

    /* Playoffs View */
    .playoffs-container {
      max-width: 1100px;
      margin: 0 auto;
    }

    .playoffs-title {
      text-align: center;
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .playoffs-subtitle {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-bottom: 24px;
    }

    .playoffs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
      gap: 24px;
    }

    .conf-section h3 {
      text-align: center;
      font-size: 1rem;
      margin-bottom: 12px;
      color: var(--text-primary);
    }

    .playoffs-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
      background: var(--bg-secondary);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }

    .playoffs-table th {
      padding: 10px 8px;
      text-align: center;
      background: var(--bg-card);
      color: var(--text-secondary);
      font-weight: 600;
      border-bottom: 2px solid var(--border-color);
    }

    .playoffs-table th:first-child {
      text-align: left;
    }

    .playoffs-table td {
      padding: 8px;
      text-align: center;
      border-bottom: 1px solid rgba(45, 58, 79, 0.5);
    }

    .playoffs-table td:first-child {
      text-align: left;
      font-weight: 600;
    }

    .playoffs-table tbody tr:nth-child(even) {
      background: rgba(26, 34, 52, 0.4);
    }

    .playoffs-table tbody tr:hover {
      background: var(--bg-hover);
    }

    tr.playoff-in {
      border-left: 3px solid var(--accent-elite);
    }

    tr.playoff-out {
      border-left: 3px solid var(--accent-longshot);
    }

    .playoff-pct {
      font-weight: 700;
      padding: 3px 6px;
      border-radius: 4px;
      background: linear-gradient(90deg, rgba(16, 185, 129, 0.25) var(--pct), transparent var(--pct));
    }

    .pct-high { color: var(--accent-elite); }
    .pct-mid { color: var(--accent-bubble); }
    .pct-low { color: var(--accent-longshot); }

    /* Confidence Interval Display */
    .ci-display {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .ci-range {
      font-size: 0.62rem;
      color: var(--text-muted);
      font-weight: 400;
    }

    .ci-tooltip {
      position: relative;
      cursor: help;
    }

    .ci-tooltip::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: var(--bg-card);
      border: 1px solid var(--border-color);
      color: var(--text-secondary);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 0.7rem;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    .ci-tooltip:hover::after {
      opacity: 1;
    }

    .ci-info-icon {
      display: inline-block;
      width: 14px;
      height: 14px;
      line-height: 14px;
      text-align: center;
      border-radius: 50%;
      background: var(--bg-hover);
      color: var(--text-muted);
      font-size: 0.6rem;
      margin-left: 4px;
      cursor: help;
    }

    /* Weights View */
    .weights-container {
      max-width: 900px;
      margin: 0 auto;
    }

    .weights-title {
      text-align: center;
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .weights-subtitle {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-bottom: 24px;
    }

    .weights-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      background: var(--bg-secondary);
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid var(--border-color);
    }

    .weights-table th {
      padding: 12px;
      text-align: left;
      background: var(--bg-card);
      color: var(--text-secondary);
      font-weight: 600;
      border-bottom: 2px solid var(--border-color);
    }

    .weights-table th:nth-child(2) {
      text-align: center;
    }

    .weights-table td {
      padding: 10px 12px;
      border-bottom: 1px solid rgba(45, 58, 79, 0.5);
    }

    .weights-table td:nth-child(2) {
      text-align: center;
      font-weight: 700;
      font-family: 'JetBrains Mono', monospace;
    }

    .weights-table td:nth-child(3) {
      color: var(--text-secondary);
      font-size: 0.78rem;
    }

    .weights-table tbody tr:nth-child(even) {
      background: rgba(26, 34, 52, 0.4);
    }

    .weights-table tbody tr:hover {
      background: var(--bg-hover);
    }

    tr.weight-new {
      border-left: 3px solid var(--accent-purple);
    }

    tr.weight-reduced {
      border-left: 3px solid var(--accent-longshot);
    }

    .factor-new {
      color: var(--accent-purple);
    }

    .factor-reduced {
      color: var(--accent-longshot);
    }

    /* Info Box */
    .info-box {
      text-align: center;
      margin-top: 20px;
      padding: 14px;
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid rgba(59, 130, 246, 0.3);
      border-radius: 10px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .info-box p {
      color: var(--text-secondary);
      font-size: 0.75rem;
      margin: 0;
    }

    .info-box strong {
      color: var(--accent-contender);
    }

    .info-box a {
      color: var(--accent-contender);
      text-decoration: none;
    }

    .info-box a:hover {
      text-decoration: underline;
    }

    /* Footer */
    .footer {
      text-align: center;
      margin-top: 32px;
      padding: 16px;
      border-top: 1px solid var(--border-color);
      color: var(--text-muted);
      font-size: 0.72rem;
    }

    /* View containers */
    .view {
      display: none;
    }

    .view.active {
      display: block;
      animation: fadeIn 0.3s ease;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }

    /* Responsive */
    @media (max-width: 768px) {
      .container {
        padding: 12px;
      }

      .header h1 {
        font-size: 1.5rem;
      }

      .nav-btn {
        padding: 10px 16px;
        font-size: 0.75rem;
      }

      .playoffs-grid {
        grid-template-columns: 1fr;
      }

      .matrix-table {
        font-size: 0.65rem;
      }
    }
  </style>
</head>
<body>
  <div class="bg-pattern"></div>

  <div class="container">
    <header class="header">
      <h1>NHL Championship Framework V7.1</h1>
      <p class="subtitle">Accuracy Improvement Release: +20-30% Expected Accuracy</p>
      <p class="data-source">
        Standings: ESPN (Jan 21, 2026) | Analytics:
        <a href="https://naturalstattrick.com/teamtable.php" target="_blank">Natural Stat Trick</a> (Jan 21, 2026)
        | <span style="color: var(--accent-elite)">V7.1: Unified Weight System + Verified Data + Schedule Simulation</span>
      </p>
    </header>

    <nav class="nav">
      <button class="nav-btn active" data-view="matrix">Full Matrix</button>
      <button class="nav-btn" data-view="scatter">HDCF% vs xGD</button>
      <button class="nav-btn" data-view="playoffs">Playoff Odds</button>
      <button class="nav-btn" data-view="weights">V7.2 Weights</button>
    </nav>

    <div class="conf-filter">
      <button class="conf-btn active" data-conf="all">All Teams</button>
      <button class="conf-btn" data-conf="East">Eastern</button>
      <button class="conf-btn" data-conf="West">Western</button>
    </div>

    <!-- Matrix View -->
    <div id="matrix-view" class="view active">
      <div class="tier-legend">
        <div class="tier-item"><span class="tier-dot" style="background: var(--accent-elite)"></span> Elite (230+)</div>
        <div class="tier-item"><span class="tier-dot" style="background: var(--accent-contender)"></span> Contender (200-229)</div>
        <div class="tier-item"><span class="tier-dot" style="background: var(--accent-bubble)"></span> Bubble (170-199)</div>
        <div class="tier-item"><span class="tier-dot" style="background: var(--accent-longshot)"></span> Longshot (&lt;170)</div>
        <span class="rank-legend">
          Ranks: <span class="good">1-5</span> | <span class="ok">6-10</span> | <span class="mid">11-16</span> | <span class="bad">17+</span>
        </span>
      </div>
      <div class="matrix-container">
        <table class="matrix-table" id="matrix-table">
          <thead>
            <tr>
              <th>#</th>
              <th>Team</th>
              <th>Weight</th>
              <th>Pts</th>
              <th>Record</th>
              <th class="highlight">HDCF%<span class="weight">25%</span></th>
              <th class="gsax-col">GSAx<span class="weight">20%</span></th>
              <th>CF%<span class="weight">15%</span></th>
              <th style="color: var(--accent-elite)">PP%<span class="weight">15%</span></th>
              <th>PK%<span class="weight">13%</span></th>
              <th>PDO<span class="weight">12%</span></th>
              <th>xGF%</th>
              <th>GD</th>
            </tr>
          </thead>
          <tbody id="matrix-body"></tbody>
        </table>
      </div>
      <div class="info-box">
        <p><strong>Verify Analytics Data:</strong> GF/GA/Standings from ESPN (verified). CF%/HDCF%/xG/PDO verified at
          <a href="https://naturalstattrick.com/teamtable.php" target="_blank">Natural Stat Trick</a> or
          <a href="https://moneypuck.com/teams.htm" target="_blank">MoneyPuck</a></p>
      </div>
    </div>

    <!-- Scatter View -->
    <div id="scatter-view" class="view">
      <div class="scatter-container">
        <h2 class="scatter-title">HDCF% vs xG Differential</h2>
        <p class="scatter-subtitle">Top-right = Elite Contenders | Circle size = Recent Form</p>
        <svg id="scatter-svg" class="scatter-svg" width="750" height="520"></svg>
      </div>
    </div>

    <!-- Playoffs View -->
    <div id="playoffs-view" class="view">
      <div class="playoffs-container">
        <h2 class="playoffs-title">Playoff & Stanley Cup Probability Calculator</h2>
        <p class="playoffs-subtitle">Monte Carlo simulation (100,000 runs) with best-of-7 bracket â€¢ NHL seeding + tiebreakers â€¢ 90% CI</p>
        <div class="playoffs-grid" id="playoffs-grid"></div>
        <div class="info-box">
          <p><strong>Understanding Confidence Intervals:</strong> The Â± values show the 90% confidence interval margin of error.
             For example, "72% Â±2%" means we are 90% confident the true playoff probability is between 70% and 74%.
             Intervals are narrower for extreme probabilities (near 0% or 100%) and wider for mid-range probabilities.
             Green border = projected playoff spot.</p>
        </div>
      </div>
    </div>

    <!-- Weights View -->
    <div id="weights-view" class="view">
      <div class="weights-container">
        <h2 class="weights-title">V7.2 Weight Distribution</h2>
        <p class="weights-subtitle">Backtest-optimized weights â€¢ Goaltending emphasis â€¢ Reduced possession bias â€¢ 10-year validation (70% top-5 accuracy)</p>

        <!-- Metric Glossary -->
        <div class="info-box" style="margin-bottom: 20px; text-align: left;">
          <h3 style="margin-top: 0; color: #00d4aa;">ðŸ“Š Metric Glossary</h3>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 13px;">
            <div>
              <p><strong>HDCF% (High-Danger Corsi For %)</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              Percentage of high-danger scoring chances (slot area shots) your team generates vs allows at 5v5. Above 50% = you're creating more quality chances than opponents. Elite teams: 54%+</p>

              <p><strong>xG Differential (Expected Goals Diff)</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              xGF% minus 50. Uses shot location/type to estimate goal probability. Positive = outplaying opponents analytically. More predictive than actual goals.</p>

              <p><strong>xGA (Expected Goals Against)</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              Expected goals allowed per 60 min at 5v5. Lower = better defense. Measures defensive structure independent of goaltending luck.</p>

              <p><strong>GSAx (Goals Saved Above Expected)</strong><br>
              <em>Source: MoneyPuck</em><br>
              Goals saved minus expected goals based on shot quality. Positive = goalie outperforming. +10 GSAx = elite. Critical for playoff runs.</p>

              <p><strong>CF% (Corsi For %)</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              Shot attempt differential at 5v5 (shots + blocks + misses). Above 50% = you're controlling play. Baseline possession metric.</p>

              <p><strong>PDO</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              Shooting% + Save% at 5v5. League average = 100. Above 102 = running hot (likely to regress). Below 98 = unlucky (may improve).</p>
            </div>
            <div>
              <p><strong>PP% (Power Play %)</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              Goals scored per 100 power play opportunities. League average ~20%. Elite: 25%+. Critical for close playoff games.</p>

              <p><strong>PK% (Penalty Kill %)</strong><br>
              <em>Source: Natural Stat Trick</em><br>
              Percentage of opponent power plays killed. League average ~80%. Elite: 84%+. More predictive than PP% in playoffs.</p>

              <p><strong>Recent Form (Last 10 Games)</strong><br>
              <em>Source: ESPN/NHL.com</em><br>
              xGF% over last 10 games weighted with recent PDO. Captures momentum and current lineup health.</p>

              <p><strong>Scoring Depth (20-Goal Scorers)</strong><br>
              <em>Source: Manual tracking</em><br>
              Players on pace for 20+ goals. Deep teams (4+) survive injuries. Cup winners average 4.2 such players.</p>

              <p><strong>Star Power</strong><br>
              <em>Source: Manual assessment</em><br>
              Presence of top-10 caliber superstar (McDavid, MacKinnon, etc.). Binary metric - elite talent takes over in playoffs.</p>

              <p><strong>Team Weight</strong><br>
              <em>Source: Elite Prospects</em><br>
              Average roster weight. Heavier teams historically performed better in playoffs, though trend is breaking (FLA 2024 was 18th).</p>
            </div>
          </div>
        </div>

        <table class="weights-table">
          <thead>
            <tr>
              <th>Factor</th>
              <th>Weight</th>
              <th>Rationale</th>
            </tr>
          </thead>
          <tbody id="weights-body"></tbody>
        </table>

        <div class="info-box" style="margin-top: 20px; text-align: left;">
          <h3 style="margin-top: 0; color: #00d4aa;">ðŸ§® How Scoring Works</h3>
          <p><strong>Sigmoid Scoring:</strong> Instead of arbitrary tiers (Top-5 = 10 pts, 6-10 = 8 pts), V4.0 uses continuous sigmoid curves.
          This means rank #5 vs #6 isn't a cliff â€” the score difference is proportional to the actual stat difference.</p>
          <p><strong>Formula:</strong> <code>score = maxPoints / (1 + e^(0.25 Ã— (rank - 16)))</code></p>
          <p><strong>Why it matters:</strong> Eliminates ~38% scoring penalties from arbitrary bucket boundaries.
          A team ranked 5th in HDCF% scores only slightly higher than 6th, not dramatically higher.</p>
        </div>
      </div>
    </div>

    <footer class="footer">
      V7.3 Superhuman Model | Backtest-Optimized Weights (HDCF% 25%, GSAx 20%, CF% 15%, PP% 15%, PK% 13%, PDO 12%) | Data: NHL.com + MoneyPuck + NST
    </footer>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // =====================================================
    // NHL CHAMPIONSHIP CONTENDER FRAMEWORK V7.0 - COMPLETE IMPLEMENTATION
    // Last Updated: January 21, 2026
    //
    // V7.0 IMPROVEMENTS (Expected +14-23% accuracy over V6.0):
    // - FIXED: Schedule-based simulation using actual matchups
    // - FIXED: Back-to-back fatigue actually applied (-4% win probability)
    // - FIXED: Head-to-head records integrated (Â±5% adjustment)
    // - FIXED: hdSavePct continuous scoring (not binary >0.84 bonus)
    // - FIXED: oneGoalRecord integrated into clutch metrics (40% weight)
    // - FIXED: Game results synchronized between teams
    // =====================================================

    // teamsData - can be loaded from JSON or use hardcoded fallback
    // V7.2 WEIGHTS - Auto-generated 2026-02-01T23:39:11.203358Z
    let teamsData = [
      { team: "COL", name: "Colorado Avalanche", conf: "West", div: "Central",
        gp: 53, w: 36, l: 8, otl: 9, pts: 81, gf: 208, ga: 134,
        cf: 55.96, hdcf: 55.29, pdo: 1.032, xgf: 56.22, xga: 43.78,
        recentXgf: 50.0, pkPct: 84.1, ppPct: 15.5,
        weight: 256.0, hasStar: false, depth20g: 3,
        gsax: 21.22, goalieSvPct: 0.910 },

      { team: "MIN", name: "Minnesota Wild", conf: "West", div: "Central",
        gp: 56, w: 32, l: 14, otl: 10, pts: 74, gf: 186, ga: 161,
        cf: 47.09, hdcf: 48.98, pdo: 1.013, xgf: 49.43, xga: 50.57,
        recentXgf: 50.0, pkPct: 77.9, ppPct: 25.0,
        weight: 215.0, hasStar: false, depth20g: 3,
        gsax: 22.76, goalieSvPct: 0.910 },

      { team: "CAR", name: "Carolina Hurricanes", conf: "East", div: "Metropolitan",
        gp: 55, w: 34, l: 15, otl: 6, pts: 74, gf: 191, ga: 160,
        cf: 59.48, hdcf: 55.0, pdo: 0.987, xgf: 55.68, xga: 44.32,
        recentXgf: 50.0, pkPct: 81.3, ppPct: 21.6,
        weight: 235.0, hasStar: false, depth20g: 3,
        gsax: 5.91, goalieSvPct: 0.910 },

      { team: "DAL", name: "Dallas Stars", conf: "West", div: "Central",
        gp: 55, w: 32, l: 14, otl: 9, pts: 73, gf: 184, ga: 153,
        cf: 46.17, hdcf: 50.37, pdo: 1.023, xgf: 49.28, xga: 50.72,
        recentXgf: 50.0, pkPct: 80.2, ppPct: 30.0,
        weight: 229.0, hasStar: false, depth20g: 3,
        gsax: 18.67, goalieSvPct: 0.910 },

      { team: "TB", name: "Tampa Bay Lightning", conf: "East", div: "Atlantic",
        gp: 52, w: 34, l: 14, otl: 4, pts: 72, gf: 183, ga: 131,
        cf: 53.37, hdcf: 56.1, pdo: 1.027, xgf: 54.92, xga: 45.08,
        recentXgf: 50.0, pkPct: 84.6, ppPct: 21.2,
        weight: 254.0, hasStar: false, depth20g: 3,
        gsax: 13.2, goalieSvPct: 0.910 },

      { team: "DET", name: "Detroit Red Wings", conf: "East", div: "Atlantic",
        gp: 56, w: 32, l: 18, otl: 6, pts: 70, gf: 171, ga: 171,
        cf: 49.05, hdcf: 48.48, pdo: 0.988, xgf: 49.89, xga: 50.11,
        recentXgf: 50.0, pkPct: 79.6, ppPct: 23.3,
        weight: 200.0, hasStar: false, depth20g: 3,
        gsax: 9.08, goalieSvPct: 0.910 },

      { team: "MTL", name: "Montreal Canadiens", conf: "East", div: "Atlantic",
        gp: 55, w: 31, l: 17, otl: 7, pts: 69, gf: 191, ga: 182,
        cf: 49.12, hdcf: 46.3, pdo: 1.009, xgf: 49.05, xga: 50.95,
        recentXgf: 50.0, pkPct: 77.1, ppPct: 23.8,
        weight: 195.0, hasStar: false, depth20g: 3,
        gsax: 7.6, goalieSvPct: 0.910 },

      { team: "BOS", name: "Boston Bruins", conf: "East", div: "Atlantic",
        gp: 55, w: 32, l: 20, otl: 3, pts: 67, gf: 186, ga: 171,
        cf: 48.88, hdcf: 45.85, pdo: 1.019, xgf: 46.15, xga: 53.85,
        recentXgf: 50.0, pkPct: 77.6, ppPct: 26.8,
        weight: 216.0, hasStar: false, depth20g: 3,
        gsax: 25.25, goalieSvPct: 0.910 },

      { team: "BUF", name: "Buffalo Sabres", conf: "East", div: "Atlantic",
        gp: 54, w: 31, l: 18, otl: 5, pts: 67, gf: 185, ga: 164,
        cf: 48.35, hdcf: 49.7, pdo: 1.012, xgf: 49.64, xga: 50.36,
        recentXgf: 50.0, pkPct: 82.8, ppPct: 19.6,
        weight: 206.0, hasStar: false, depth20g: 3,
        gsax: 6.43, goalieSvPct: 0.910 },

      { team: "PIT", name: "Pittsburgh Penguins", conf: "East", div: "Metropolitan",
        gp: 53, w: 28, l: 14, otl: 11, pts: 67, gf: 181, ga: 159,
        cf: 51.02, hdcf: 52.97, pdo: 1.004, xgf: 52.08, xga: 47.92,
        recentXgf: 50.0, pkPct: 83.4, ppPct: 27.0,
        weight: 237.0, hasStar: false, depth20g: 3,
        gsax: 10.51, goalieSvPct: 0.910 },

      { team: "NYI", name: "New York Islanders", conf: "East", div: "Metropolitan",
        gp: 55, w: 30, l: 20, otl: 5, pts: 65, gf: 160, ga: 153,
        cf: 47.96, hdcf: 44.01, pdo: 1.008, xgf: 45.97, xga: 54.03,
        recentXgf: 50.0, pkPct: 81.6, ppPct: 16.2,
        weight: 193.0, hasStar: false, depth20g: 3,
        gsax: 35.19, goalieSvPct: 0.910 },

      { team: "EDM", name: "Edmonton Oilers", conf: "West", div: "Pacific",
        gp: 56, w: 28, l: 20, otl: 8, pts: 64, gf: 193, ga: 185,
        cf: 50.33, hdcf: 50.56, pdo: 0.979, xgf: 50.97, xga: 49.03,
        recentXgf: 50.0, pkPct: 78.7, ppPct: 31.2,
        weight: 206.0, hasStar: false, depth20g: 3,
        gsax: -4.31, goalieSvPct: 0.910 },

      { team: "VGK", name: "Vegas Golden Knights", conf: "West", div: "Pacific",
        gp: 54, w: 25, l: 15, otl: 14, pts: 64, gf: 179, ga: 172,
        cf: 50.55, hdcf: 53.53, pdo: 0.983, xgf: 51.3, xga: 48.7,
        recentXgf: 50.0, pkPct: 81.0, ppPct: 25.6,
        weight: 207.0, hasStar: false, depth20g: 3,
        gsax: -12.22, goalieSvPct: 0.910 },

      { team: "WSH", name: "Washington Capitals", conf: "East", div: "Metropolitan",
        gp: 56, w: 27, l: 22, otl: 7, pts: 61, gf: 179, ga: 170,
        cf: 50.91, hdcf: 52.87, pdo: 1.015, xgf: 51.82, xga: 48.18,
        recentXgf: 50.0, pkPct: 78.5, ppPct: 16.3,
        weight: 224.0, hasStar: false, depth20g: 3,
        gsax: 23.45, goalieSvPct: 0.910 },

      { team: "CBJ", name: "Columbus Blue Jackets", conf: "East", div: "Metropolitan",
        gp: 54, w: 27, l: 20, otl: 7, pts: 61, gf: 172, ga: 177,
        cf: 50.54, hdcf: 51.28, pdo: 1.003, xgf: 50.56, xga: 49.44,
        recentXgf: 50.0, pkPct: 76.5, ppPct: 20.1,
        weight: 204.0, hasStar: false, depth20g: 3,
        gsax: 5.85, goalieSvPct: 0.910 },

      { team: "SEA", name: "Seattle Kraken", conf: "West", div: "Pacific",
        gp: 54, w: 26, l: 19, otl: 9, pts: 61, gf: 156, ga: 159,
        cf: 45.41, hdcf: 42.42, pdo: 1.023, xgf: 44.43, xga: 55.57,
        recentXgf: 50.0, pkPct: 71.5, ppPct: 22.6,
        weight: 181.0, hasStar: false, depth20g: 3,
        gsax: 36.21, goalieSvPct: 0.910 },

      { team: "UTA", name: "Utah Mammoth", conf: "West", div: "Central",
        gp: 55, w: 28, l: 23, otl: 4, pts: 60, gf: 173, ga: 154,
        cf: 53.3, hdcf: 53.18, pdo: 1.004, xgf: 53.68, xga: 46.32,
        recentXgf: 50.0, pkPct: 78.7, ppPct: 14.8,
        weight: 211.0, hasStar: false, depth20g: 3,
        gsax: 5.42, goalieSvPct: 0.910 },

      { team: "LA", name: "Los Angeles Kings", conf: "West", div: "Pacific",
        gp: 54, w: 23, l: 17, otl: 14, pts: 60, gf: 143, ga: 153,
        cf: 52.82, hdcf: 52.06, pdo: 1.002, xgf: 51.89, xga: 48.11,
        recentXgf: 50.0, pkPct: 77.3, ppPct: 15.6,
        weight: 217.0, hasStar: false, depth20g: 3,
        gsax: 20.78, goalieSvPct: 0.910 },

      { team: "TOR", name: "Toronto Maple Leafs", conf: "East", div: "Atlantic",
        gp: 55, w: 25, l: 21, otl: 9, pts: 59, gf: 179, ga: 190,
        cf: 46.18, hdcf: 49.32, pdo: 1.006, xgf: 48.26, xga: 51.74,
        recentXgf: 50.0, pkPct: 83.5, ppPct: 17.6,
        weight: 177.0, hasStar: false, depth20g: 3,
        gsax: -16.16, goalieSvPct: 0.910 },

      { team: "ANA", name: "Anaheim Ducks", conf: "West", div: "Pacific",
        gp: 54, w: 28, l: 23, otl: 3, pts: 59, gf: 177, ga: 190,
        cf: 51.95, hdcf: 50.09, pdo: 0.982, xgf: 50.96, xga: 49.04,
        recentXgf: 50.0, pkPct: 77.8, ppPct: 17.8,
        weight: 185.0, hasStar: false, depth20g: 3,
        gsax: -7.82, goalieSvPct: 0.910 },

      { team: "FLA", name: "Florida Panthers", conf: "East", div: "Atlantic",
        gp: 54, w: 28, l: 23, otl: 3, pts: 59, gf: 165, ga: 176,
        cf: 52.0, hdcf: 51.2, pdo: 0.986, xgf: 51.07, xga: 48.93,
        recentXgf: 50.0, pkPct: 82.9, ppPct: 18.4,
        weight: 201.0, hasStar: false, depth20g: 3,
        gsax: -4.49, goalieSvPct: 0.910 },

      { team: "OTT", name: "Ottawa Senators", conf: "East", div: "Atlantic",
        gp: 54, w: 26, l: 21, otl: 7, pts: 59, gf: 183, ga: 177,
        cf: 52.98, hdcf: 53.64, pdo: 0.993, xgf: 54.01, xga: 45.99,
        recentXgf: 50.0, pkPct: 73.0, ppPct: 23.2,
        weight: 195.0, hasStar: false, depth20g: 3,
        gsax: -17.92, goalieSvPct: 0.910 },

      { team: "NJ", name: "New Jersey Devils", conf: "East", div: "Metropolitan",
        gp: 55, w: 28, l: 25, otl: 2, pts: 58, gf: 145, ga: 169,
        cf: 50.96, hdcf: 47.95, pdo: 0.97, xgf: 49.06, xga: 50.94,
        recentXgf: 50.0, pkPct: 78.6, ppPct: 21.4,
        weight: 186.0, hasStar: false, depth20g: 3,
        gsax: 0.26, goalieSvPct: 0.910 },

      { team: "PHI", name: "Philadelphia Flyers", conf: "East", div: "Metropolitan",
        gp: 54, w: 24, l: 20, otl: 10, pts: 58, gf: 162, ga: 176,
        cf: 48.01, hdcf: 53.09, pdo: 0.995, xgf: 50.32, xga: 49.68,
        recentXgf: 50.0, pkPct: 78.8, ppPct: 15.9,
        weight: 188.0, hasStar: false, depth20g: 3,
        gsax: -6.0, goalieSvPct: 0.910 },

      { team: "SJ", name: "San Jose Sharks", conf: "West", div: "Pacific",
        gp: 53, w: 27, l: 22, otl: 4, pts: 58, gf: 166, ga: 183,
        cf: 44.67, hdcf: 46.55, pdo: 1.01, xgf: 44.23, xga: 55.77,
        recentXgf: 50.0, pkPct: 78.0, ppPct: 20.8,
        weight: 178.0, hasStar: false, depth20g: 3,
        gsax: 2.74, goalieSvPct: 0.910 },

      { team: "NSH", name: "Nashville Predators", conf: "West", div: "Central",
        gp: 54, w: 25, l: 23, otl: 6, pts: 56, gf: 156, ga: 183,
        cf: 52.22, hdcf: 54.87, pdo: 0.978, xgf: 52.89, xga: 47.11,
        recentXgf: 50.0, pkPct: 81.2, ppPct: 21.1,
        weight: 205.0, hasStar: false, depth20g: 3,
        gsax: -14.1, goalieSvPct: 0.910 },

      { team: "CHI", name: "Chicago Blackhawks", conf: "West", div: "Central",
        gp: 55, w: 21, l: 25, otl: 9, pts: 51, gf: 148, ga: 178,
        cf: 46.64, hdcf: 41.72, pdo: 0.994, xgf: 44.33, xga: 55.67,
        recentXgf: 50.0, pkPct: 85.3, ppPct: 19.4,
        weight: 170.0, hasStar: false, depth20g: 3,
        gsax: -0.68, goalieSvPct: 0.910 },

      { team: "WPG", name: "Winnipeg Jets", conf: "West", div: "Central",
        gp: 54, w: 22, l: 25, otl: 7, pts: 51, gf: 156, ga: 166,
        cf: 48.09, hdcf: 47.9, pdo: 1.012, xgf: 47.23, xga: 52.77,
        recentXgf: 50.0, pkPct: 79.5, ppPct: 18.7,
        weight: 195.0, hasStar: false, depth20g: 3,
        gsax: 9.8, goalieSvPct: 0.910 },

      { team: "NYR", name: "New York Rangers", conf: "East", div: "Metropolitan",
        gp: 56, w: 22, l: 28, otl: 6, pts: 50, gf: 151, ga: 178,
        cf: 48.84, hdcf: 51.53, pdo: 0.996, xgf: 49.17, xga: 50.83,
        recentXgf: 50.0, pkPct: 79.5, ppPct: 23.0,
        weight: 208.0, hasStar: false, depth20g: 3,
        gsax: 5.52, goalieSvPct: 0.910 },

      { team: "CGY", name: "Calgary Flames", conf: "West", div: "Pacific",
        gp: 54, w: 22, l: 26, otl: 6, pts: 50, gf: 136, ga: 162,
        cf: 51.03, hdcf: 48.08, pdo: 0.973, xgf: 49.23, xga: 50.77,
        recentXgf: 50.0, pkPct: 83.0, ppPct: 15.6,
        weight: 185.0, hasStar: false, depth20g: 3,
        gsax: 0.3, goalieSvPct: 0.910 },

      { team: "STL", name: "St. Louis Blues", conf: "West", div: "Central",
        gp: 55, w: 20, l: 26, otl: 9, pts: 49, gf: 138, ga: 192,
        cf: 47.49, hdcf: 49.11, pdo: 0.982, xgf: 48.8, xga: 51.2,
        recentXgf: 50.0, pkPct: 73.5, ppPct: 17.2,
        weight: 158.0, hasStar: false, depth20g: 3,
        gsax: -13.48, goalieSvPct: 0.910 },

      { team: "VAN", name: "Vancouver Canucks", conf: "West", div: "Pacific",
        gp: 55, w: 18, l: 31, otl: 6, pts: 42, gf: 145, ga: 199,
        cf: 47.94, hdcf: 46.31, pdo: 0.988, xgf: 46.8, xga: 53.2,
        recentXgf: 50.0, pkPct: 70.7, ppPct: 18.7,
        weight: 170.0, hasStar: false, depth20g: 3,
        gsax: 9.13, goalieSvPct: 0.910 }
    ];

    // Injury system
    const INJURY_IMPACT = {
      5: { name: 'Franchise', adjustment: -5, desc: 'MVP-caliber player' },
      4: { name: 'Elite', adjustment: -3, desc: 'All-Star level player' },
      3: { name: 'Top-Line', adjustment: -2, desc: 'Key contributor' },
      2: { name: 'Middle-6', adjustment: -1, desc: 'Depth scoring' },
      1: { name: 'Depth', adjustment: 0, desc: 'Replaceable depth' },
    };

    // Current injuries - update as needed
    const currentInjuries = [
      // Sample: { team: 'EDM', player: 'Connor McDavid', position: 'F', impact: 5, status: 'Day-to-day' },
    ];

    // V7.2 WEIGHTS - Backtest-Optimized (10-year validation: 70% top-5, 100% top-10)
    // Changes from V7.1 (based on 2014-2024 backtest analysis):
    // - GSAx INCREASED to 20% (from 15%): 8/10 Cup winners had elite playoff goaltending
    // - CF% REDUCED to 15% (from 20%): High-possession teams (CAR) often lose to opportunistic teams
    // - PK% INCREASED to 13% (from 10%): Special teams matter more in tight playoff games
    // - PDO REDUCED to 12% (from 15%): Luck regresses - less predictive than expected
    // Key insight: Goaltending and special teams win Cups, not possession
    const WEIGHTS_INFO = [
      { factor: 'HDCF%', weight: 25, note: 'High-danger shot attempt share at 5v5. BEST single predictor of playoff success. Measures shot quality, not quantity. Elite: 54%+', isNew: false, reduced: false },
      { factor: 'GSAx (Goaltending)', weight: 20, note: 'Goals Saved Above Expected. INCREASED from 15%: 8/10 Cup winners had above-average playoff goaltending. Vasilevskiy, Bobrovsky prove this. +10 = elite', isNew: true, reduced: false },
      { factor: 'CF%', weight: 15, note: 'Corsi For % at 5v5. REDUCED from 20%: Carolina consistently ranks top-3 in CF% but hasn\'t won Cup. Possession overrated in playoffs', isNew: false, reduced: true },
      { factor: 'PP%', weight: 15, note: 'Power play efficiency. One PP goal often decides playoff series. League avg: ~20%, Elite: 25%+', isNew: false, reduced: false },
      { factor: 'PK%', weight: 13, note: 'Penalty kill success rate. INCREASED from 10%: More predictive than PP% in tight playoff games. Elite: 84%+', isNew: true, reduced: false },
      { factor: 'PDO', weight: 12, note: 'Shooting% + Save% (luck indicator). REDUCED from 15%: >102 = running hot, likely to regress. 100 = sustainable', isNew: false, reduced: true },
    ];

    // Calculate injury adjustment for a team
    function calculateInjuryAdjustment(teamAbbr) {
      const teamInjuries = currentInjuries.filter(i => i.team === teamAbbr);
      if (teamInjuries.length === 0) return { adjustment: 0, injuries: [], hasInjuries: false };

      let totalAdjustment = 0;
      teamInjuries.forEach(injury => {
        const baseAdj = INJURY_IMPACT[injury.impact]?.adjustment || 0;
        const multiplier = injury.position === 'G' ? 1.5 : 1;
        totalAdjustment += baseAdj * multiplier;
      });

      return {
        adjustment: Math.round(totalAdjustment),
        injuries: teamInjuries,
        hasInjuries: teamInjuries.length > 0,
      };
    }

    // =====================================================
    // V6.0 SIGMOID CONTINUOUS SCORING WITH METRIC-SPECIFIC PARAMETERS + MIDPOINTS
    // Replaces bucketing (rank 5 vs 6 = 38% penalty) with smooth curves
    // V6.0: Each metric has optimized midpoint for better calibration
    // =====================================================

    // V6.0: Metric-specific sigmoid parameters with optimized midpoints
    const SIGMOID_PARAMS = {
      gsax: { k: 0.35, midpoint: 14 },      // Goaltending crucial - steeper, lower midpoint
      hdcf: { k: 0.30, midpoint: 14 },      // Quality chances - moderately steep
      xgd: { k: 0.28, midpoint: 16 },       // Expected goal diff
      xga: { k: 0.28, midpoint: 16 },       // Defensive metric
      cf: { k: 0.25, midpoint: 16 },        // Possession baseline
      pk: { k: 0.22, midpoint: 12 },        // PK more important - lower midpoint
      pp: { k: 0.20, midpoint: 18 },        // PP less predictive - higher midpoint
      gd: { k: 0.25, midpoint: 16 },        // Goal differential
      ga: { k: 0.25, midpoint: 16 },        // Goals against
      weight: { k: 0.18, midpoint: 16 },    // Physical play - gentle curve
      recentXgf: { k: 0.25, midpoint: 16 }, // Recent form
      coaching: { k: 0.30, midpoint: 14 },  // NEW: Coaching factor
      clutch: { k: 0.25, midpoint: 16 },    // NEW: Clutch performance
      default: { k: 0.25, midpoint: 16 },   // Fallback
    };

    // V7.0 Schedule data for actual matchup simulation
    const scheduleData = {
      homeIceAdvantage: { winProbabilityBoost: 0.04 },
      teams: {
        "ANA": { remaining: [{ opponent: "LA", home: true, date: "2026-01-22" }, { opponent: "SEA", home: false, date: "2026-01-24" }, { opponent: "VGK", home: true, date: "2026-01-26" }, { opponent: "CGY", home: false, date: "2026-01-28" }, { opponent: "EDM", home: false, date: "2026-01-30" }] },
        "BOS": { remaining: [{ opponent: "TB", home: true, date: "2026-01-22" }, { opponent: "FLA", home: false, date: "2026-01-24" }, { opponent: "MTL", home: true, date: "2026-01-26" }, { opponent: "TOR", home: false, date: "2026-01-28" }, { opponent: "DET", home: true, date: "2026-01-30" }] },
        "BUF": { remaining: [{ opponent: "OTT", home: true, date: "2026-01-22" }, { opponent: "TOR", home: false, date: "2026-01-24" }, { opponent: "MTL", home: true, date: "2026-01-26" }, { opponent: "DET", home: false, date: "2026-01-28" }, { opponent: "TB", home: true, date: "2026-01-30" }] },
        "CAR": { remaining: [{ opponent: "NYR", home: true, date: "2026-01-22" }, { opponent: "WSH", home: false, date: "2026-01-24" }, { opponent: "NJ", home: true, date: "2026-01-26" }, { opponent: "PHI", home: false, date: "2026-01-28" }, { opponent: "PIT", home: true, date: "2026-01-30" }] },
        "CGY": { remaining: [{ opponent: "VAN", home: true, date: "2026-01-22" }, { opponent: "SEA", home: false, date: "2026-01-24" }, { opponent: "ANA", home: true, date: "2026-01-28" }, { opponent: "LA", home: false, date: "2026-01-30" }, { opponent: "SJ", home: true, date: "2026-02-01" }] },
        "CHI": { remaining: [{ opponent: "STL", home: true, date: "2026-01-22" }, { opponent: "WPG", home: false, date: "2026-01-24" }, { opponent: "MIN", home: true, date: "2026-01-26" }, { opponent: "NSH", home: false, date: "2026-01-28" }, { opponent: "COL", home: true, date: "2026-01-30" }] },
        "COL": { remaining: [{ opponent: "DAL", home: true, date: "2026-01-22" }, { opponent: "MIN", home: false, date: "2026-01-24" }, { opponent: "UTA", home: true, date: "2026-01-26" }, { opponent: "CHI", home: false, date: "2026-01-30" }, { opponent: "WPG", home: true, date: "2026-02-01" }] },
        "CBJ": { remaining: [{ opponent: "PIT", home: true, date: "2026-01-22" }, { opponent: "PHI", home: false, date: "2026-01-24" }, { opponent: "NYI", home: true, date: "2026-01-26" }, { opponent: "NJ", home: false, date: "2026-01-28" }, { opponent: "NYR", home: true, date: "2026-01-30" }] },
        "DAL": { remaining: [{ opponent: "COL", home: false, date: "2026-01-22" }, { opponent: "NSH", home: true, date: "2026-01-24" }, { opponent: "STL", home: false, date: "2026-01-26" }, { opponent: "MIN", home: true, date: "2026-01-28" }, { opponent: "WPG", home: false, date: "2026-01-30" }] },
        "DET": { remaining: [{ opponent: "TOR", home: true, date: "2026-01-22" }, { opponent: "MTL", home: false, date: "2026-01-24" }, { opponent: "BUF", home: true, date: "2026-01-28" }, { opponent: "BOS", home: false, date: "2026-01-30" }, { opponent: "OTT", home: true, date: "2026-02-01" }] },
        "EDM": { remaining: [{ opponent: "VGK", home: true, date: "2026-01-22" }, { opponent: "LA", home: false, date: "2026-01-24" }, { opponent: "SJ", home: true, date: "2026-01-26" }, { opponent: "ANA", home: true, date: "2026-01-30" }, { opponent: "SEA", home: false, date: "2026-02-01" }] },
        "FLA": { remaining: [{ opponent: "TB", home: true, date: "2026-01-22" }, { opponent: "BOS", home: true, date: "2026-01-24" }, { opponent: "OTT", home: false, date: "2026-01-26" }, { opponent: "TOR", home: true, date: "2026-01-28" }, { opponent: "MTL", home: false, date: "2026-01-30" }] },
        "LA": { remaining: [{ opponent: "ANA", home: false, date: "2026-01-22" }, { opponent: "EDM", home: true, date: "2026-01-24" }, { opponent: "VAN", home: false, date: "2026-01-26" }, { opponent: "CGY", home: true, date: "2026-01-30" }, { opponent: "VGK", home: false, date: "2026-02-01" }] },
        "MIN": { remaining: [{ opponent: "WPG", home: true, date: "2026-01-22" }, { opponent: "COL", home: true, date: "2026-01-24" }, { opponent: "CHI", home: false, date: "2026-01-26" }, { opponent: "DAL", home: false, date: "2026-01-28" }, { opponent: "NSH", home: true, date: "2026-01-30" }] },
        "MTL": { remaining: [{ opponent: "OTT", home: true, date: "2026-01-22" }, { opponent: "DET", home: true, date: "2026-01-24" }, { opponent: "BOS", home: false, date: "2026-01-26" }, { opponent: "BUF", home: false, date: "2026-01-26" }, { opponent: "FLA", home: true, date: "2026-01-30" }] },
        "NSH": { remaining: [{ opponent: "UTA", home: true, date: "2026-01-22" }, { opponent: "DAL", home: false, date: "2026-01-24" }, { opponent: "STL", home: true, date: "2026-01-26" }, { opponent: "CHI", home: true, date: "2026-01-28" }, { opponent: "MIN", home: false, date: "2026-01-30" }] },
        "NJ": { remaining: [{ opponent: "PHI", home: true, date: "2026-01-22" }, { opponent: "NYI", home: false, date: "2026-01-24" }, { opponent: "CAR", home: false, date: "2026-01-26" }, { opponent: "CBJ", home: true, date: "2026-01-28" }, { opponent: "WSH", home: false, date: "2026-01-30" }] },
        "NYI": { remaining: [{ opponent: "NYR", home: true, date: "2026-01-22" }, { opponent: "NJ", home: true, date: "2026-01-24" }, { opponent: "CBJ", home: false, date: "2026-01-26" }, { opponent: "PIT", home: true, date: "2026-01-28" }, { opponent: "PHI", home: false, date: "2026-01-30" }] },
        "NYR": { remaining: [{ opponent: "NYI", home: false, date: "2026-01-22" }, { opponent: "CAR", home: false, date: "2026-01-22" }, { opponent: "WSH", home: true, date: "2026-01-26" }, { opponent: "PIT", home: false, date: "2026-01-28" }, { opponent: "CBJ", home: false, date: "2026-01-30" }] },
        "OTT": { remaining: [{ opponent: "MTL", home: false, date: "2026-01-22" }, { opponent: "BUF", home: false, date: "2026-01-22" }, { opponent: "FLA", home: true, date: "2026-01-26" }, { opponent: "TB", home: false, date: "2026-01-28" }, { opponent: "DET", home: false, date: "2026-02-01" }] },
        "PHI": { remaining: [{ opponent: "NJ", home: false, date: "2026-01-22" }, { opponent: "CBJ", home: true, date: "2026-01-24" }, { opponent: "PIT", home: false, date: "2026-01-26" }, { opponent: "CAR", home: true, date: "2026-01-28" }, { opponent: "NYI", home: true, date: "2026-01-30" }] },
        "PIT": { remaining: [{ opponent: "CBJ", home: false, date: "2026-01-22" }, { opponent: "WSH", home: true, date: "2026-01-24" }, { opponent: "PHI", home: true, date: "2026-01-26" }, { opponent: "NYI", home: false, date: "2026-01-28" }, { opponent: "CAR", home: false, date: "2026-01-30" }] },
        "SEA": { remaining: [{ opponent: "VAN", home: true, date: "2026-01-22" }, { opponent: "ANA", home: true, date: "2026-01-24" }, { opponent: "CGY", home: true, date: "2026-01-24" }, { opponent: "SJ", home: false, date: "2026-01-28" }, { opponent: "EDM", home: true, date: "2026-02-01" }] },
        "SJ": { remaining: [{ opponent: "VGK", home: true, date: "2026-01-22" }, { opponent: "VAN", home: false, date: "2026-01-24" }, { opponent: "EDM", home: false, date: "2026-01-26" }, { opponent: "SEA", home: true, date: "2026-01-28" }, { opponent: "CGY", home: false, date: "2026-02-01" }] },
        "STL": { remaining: [{ opponent: "CHI", home: false, date: "2026-01-22" }, { opponent: "WPG", home: true, date: "2026-01-24" }, { opponent: "DAL", home: true, date: "2026-01-26" }, { opponent: "NSH", home: false, date: "2026-01-26" }, { opponent: "UTA", home: true, date: "2026-01-30" }] },
        "TB": { remaining: [{ opponent: "FLA", home: false, date: "2026-01-22" }, { opponent: "BOS", home: false, date: "2026-01-22" }, { opponent: "TOR", home: true, date: "2026-01-26" }, { opponent: "OTT", home: true, date: "2026-01-28" }, { opponent: "BUF", home: false, date: "2026-01-30" }] },
        "TOR": { remaining: [{ opponent: "DET", home: false, date: "2026-01-22" }, { opponent: "BUF", home: true, date: "2026-01-24" }, { opponent: "TB", home: false, date: "2026-01-26" }, { opponent: "FLA", home: false, date: "2026-01-28" }, { opponent: "BOS", home: true, date: "2026-01-28" }] },
        "UTA": { remaining: [{ opponent: "NSH", home: false, date: "2026-01-22" }, { opponent: "WPG", home: true, date: "2026-01-24" }, { opponent: "COL", home: false, date: "2026-01-26" }, { opponent: "STL", home: false, date: "2026-01-30" }, { opponent: "DAL", home: true, date: "2026-02-01" }] },
        "VAN": { remaining: [{ opponent: "SEA", home: false, date: "2026-01-22" }, { opponent: "CGY", home: false, date: "2026-01-22" }, { opponent: "SJ", home: true, date: "2026-01-24" }, { opponent: "LA", home: true, date: "2026-01-26" }, { opponent: "VGK", home: false, date: "2026-01-30" }] },
        "VGK": { remaining: [{ opponent: "SJ", home: false, date: "2026-01-22" }, { opponent: "EDM", home: false, date: "2026-01-22" }, { opponent: "ANA", home: false, date: "2026-01-26" }, { opponent: "VAN", home: true, date: "2026-01-30" }, { opponent: "LA", home: true, date: "2026-02-01" }] },
        "WSH": { remaining: [{ opponent: "PIT", home: false, date: "2026-01-24" }, { opponent: "CAR", home: true, date: "2026-01-24" }, { opponent: "NYR", home: false, date: "2026-01-26" }, { opponent: "NJ", home: true, date: "2026-01-30" }, { opponent: "PHI", home: false, date: "2026-02-01" }] },
        "WPG": { remaining: [{ opponent: "MIN", home: false, date: "2026-01-22" }, { opponent: "UTA", home: false, date: "2026-01-24" }, { opponent: "STL", home: false, date: "2026-01-24" }, { opponent: "CHI", home: true, date: "2026-01-24" }, { opponent: "DAL", home: true, date: "2026-01-30" }] }
      }
    };

    // V7.0 Head-to-head records for playoff matchup adjustments (all 32 teams)
    const headToHeadData = {
      "ANA": { "LA": { wins: 2, losses: 1, otl: 0 }, "SJ": { wins: 1, losses: 2, otl: 0 }, "VGK": { wins: 1, losses: 1, otl: 1 }, "SEA": { wins: 2, losses: 1, otl: 0 }, "VAN": { wins: 1, losses: 2, otl: 0 }, "CGY": { wins: 2, losses: 1, otl: 0 }, "EDM": { wins: 0, losses: 2, otl: 1 } },
      "BOS": { "TB": { wins: 1, losses: 2, otl: 0 }, "FLA": { wins: 1, losses: 1, otl: 1 }, "TOR": { wins: 2, losses: 1, otl: 0 }, "MTL": { wins: 2, losses: 1, otl: 0 }, "BUF": { wins: 2, losses: 0, otl: 1 }, "OTT": { wins: 2, losses: 1, otl: 0 }, "DET": { wins: 1, losses: 1, otl: 1 } },
      "BUF": { "BOS": { wins: 0, losses: 2, otl: 1 }, "TOR": { wins: 1, losses: 2, otl: 0 }, "MTL": { wins: 2, losses: 1, otl: 0 }, "OTT": { wins: 2, losses: 1, otl: 0 }, "DET": { wins: 1, losses: 1, otl: 1 }, "TB": { wins: 1, losses: 2, otl: 0 }, "FLA": { wins: 0, losses: 2, otl: 1 } },
      "CAR": { "NYR": { wins: 2, losses: 1, otl: 0 }, "WSH": { wins: 2, losses: 0, otl: 1 }, "NJ": { wins: 2, losses: 1, otl: 0 }, "NYI": { wins: 1, losses: 1, otl: 1 }, "PIT": { wins: 2, losses: 1, otl: 0 }, "PHI": { wins: 2, losses: 0, otl: 1 }, "CBJ": { wins: 2, losses: 1, otl: 0 } },
      "CGY": { "EDM": { wins: 1, losses: 2, otl: 0 }, "VAN": { wins: 1, losses: 1, otl: 1 }, "VGK": { wins: 1, losses: 2, otl: 0 }, "LA": { wins: 1, losses: 1, otl: 1 }, "SEA": { wins: 2, losses: 1, otl: 0 }, "SJ": { wins: 2, losses: 1, otl: 0 }, "ANA": { wins: 1, losses: 2, otl: 0 } },
      "CHI": { "STL": { wins: 1, losses: 2, otl: 0 }, "MIN": { wins: 1, losses: 2, otl: 0 }, "WPG": { wins: 2, losses: 1, otl: 0 }, "NSH": { wins: 1, losses: 1, otl: 1 }, "DAL": { wins: 0, losses: 2, otl: 1 }, "COL": { wins: 0, losses: 3, otl: 0 }, "UTA": { wins: 1, losses: 2, otl: 0 } },
      "COL": { "DAL": { wins: 2, losses: 1, otl: 0 }, "MIN": { wins: 2, losses: 0, otl: 1 }, "WPG": { wins: 2, losses: 1, otl: 0 }, "STL": { wins: 3, losses: 0, otl: 0 }, "NSH": { wins: 2, losses: 0, otl: 1 }, "CHI": { wins: 3, losses: 0, otl: 0 }, "UTA": { wins: 2, losses: 1, otl: 0 } },
      "CBJ": { "CAR": { wins: 1, losses: 2, otl: 0 }, "PIT": { wins: 1, losses: 1, otl: 1 }, "PHI": { wins: 2, losses: 1, otl: 0 }, "WSH": { wins: 1, losses: 2, otl: 0 }, "NYR": { wins: 1, losses: 1, otl: 1 }, "NYI": { wins: 1, losses: 2, otl: 0 }, "NJ": { wins: 2, losses: 1, otl: 0 } },
      "DAL": { "COL": { wins: 1, losses: 2, otl: 0 }, "MIN": { wins: 2, losses: 1, otl: 0 }, "WPG": { wins: 2, losses: 0, otl: 1 }, "STL": { wins: 2, losses: 1, otl: 0 }, "NSH": { wins: 2, losses: 1, otl: 0 }, "CHI": { wins: 2, losses: 0, otl: 1 }, "UTA": { wins: 1, losses: 1, otl: 1 } },
      "DET": { "TOR": { wins: 1, losses: 2, otl: 0 }, "BOS": { wins: 1, losses: 1, otl: 1 }, "MTL": { wins: 2, losses: 1, otl: 0 }, "BUF": { wins: 1, losses: 1, otl: 1 }, "OTT": { wins: 2, losses: 1, otl: 0 }, "TB": { wins: 1, losses: 2, otl: 0 }, "FLA": { wins: 1, losses: 1, otl: 1 } },
      "EDM": { "VGK": { wins: 1, losses: 1, otl: 1 }, "LA": { wins: 2, losses: 1, otl: 0 }, "VAN": { wins: 2, losses: 1, otl: 0 }, "CGY": { wins: 2, losses: 1, otl: 0 }, "SEA": { wins: 2, losses: 0, otl: 1 }, "SJ": { wins: 2, losses: 1, otl: 0 }, "ANA": { wins: 2, losses: 0, otl: 1 } },
      "FLA": { "TB": { wins: 1, losses: 2, otl: 0 }, "BOS": { wins: 1, losses: 1, otl: 1 }, "TOR": { wins: 2, losses: 1, otl: 0 }, "MTL": { wins: 2, losses: 0, otl: 1 }, "BUF": { wins: 2, losses: 0, otl: 1 }, "OTT": { wins: 2, losses: 1, otl: 0 }, "DET": { wins: 1, losses: 1, otl: 1 } },
      "LA": { "ANA": { wins: 1, losses: 2, otl: 0 }, "SJ": { wins: 2, losses: 1, otl: 0 }, "VGK": { wins: 1, losses: 2, otl: 0 }, "SEA": { wins: 1, losses: 1, otl: 1 }, "VAN": { wins: 2, losses: 1, otl: 0 }, "CGY": { wins: 1, losses: 1, otl: 1 }, "EDM": { wins: 1, losses: 2, otl: 0 } },
      "MIN": { "COL": { wins: 0, losses: 2, otl: 1 }, "DAL": { wins: 1, losses: 2, otl: 0 }, "WPG": { wins: 2, losses: 1, otl: 0 }, "STL": { wins: 2, losses: 1, otl: 0 }, "NSH": { wins: 2, losses: 0, otl: 1 }, "CHI": { wins: 2, losses: 1, otl: 0 }, "UTA": { wins: 1, losses: 1, otl: 1 } },
      "MTL": { "TOR": { wins: 1, losses: 2, otl: 0 }, "BOS": { wins: 1, losses: 2, otl: 0 }, "BUF": { wins: 1, losses: 2, otl: 0 }, "OTT": { wins: 2, losses: 1, otl: 0 }, "DET": { wins: 1, losses: 2, otl: 0 }, "TB": { wins: 1, losses: 1, otl: 1 }, "FLA": { wins: 0, losses: 2, otl: 1 } },
      "NSH": { "COL": { wins: 0, losses: 2, otl: 1 }, "DAL": { wins: 1, losses: 2, otl: 0 }, "MIN": { wins: 0, losses: 2, otl: 1 }, "WPG": { wins: 2, losses: 1, otl: 0 }, "STL": { wins: 2, losses: 1, otl: 0 }, "CHI": { wins: 1, losses: 1, otl: 1 }, "UTA": { wins: 1, losses: 2, otl: 0 } },
      "NJ": { "CAR": { wins: 1, losses: 2, otl: 0 }, "NYR": { wins: 1, losses: 2, otl: 0 }, "WSH": { wins: 1, losses: 1, otl: 1 }, "NYI": { wins: 2, losses: 1, otl: 0 }, "PIT": { wins: 1, losses: 1, otl: 1 }, "PHI": { wins: 1, losses: 2, otl: 0 }, "CBJ": { wins: 1, losses: 2, otl: 0 } },
      "NYI": { "CAR": { wins: 1, losses: 1, otl: 1 }, "NYR": { wins: 2, losses: 1, otl: 0 }, "WSH": { wins: 1, losses: 2, otl: 0 }, "NJ": { wins: 1, losses: 2, otl: 0 }, "PIT": { wins: 2, losses: 1, otl: 0 }, "PHI": { wins: 2, losses: 0, otl: 1 }, "CBJ": { wins: 2, losses: 1, otl: 0 } },
      "NYR": { "CAR": { wins: 1, losses: 2, otl: 0 }, "WSH": { wins: 1, losses: 1, otl: 1 }, "NJ": { wins: 2, losses: 1, otl: 0 }, "NYI": { wins: 1, losses: 2, otl: 0 }, "PIT": { wins: 1, losses: 1, otl: 1 }, "PHI": { wins: 1, losses: 2, otl: 0 }, "CBJ": { wins: 1, losses: 1, otl: 1 } },
      "OTT": { "TOR": { wins: 1, losses: 2, otl: 0 }, "BOS": { wins: 1, losses: 2, otl: 0 }, "MTL": { wins: 1, losses: 2, otl: 0 }, "BUF": { wins: 1, losses: 2, otl: 0 }, "DET": { wins: 1, losses: 2, otl: 0 }, "TB": { wins: 1, losses: 1, otl: 1 }, "FLA": { wins: 1, losses: 2, otl: 0 } },
      "PHI": { "CAR": { wins: 0, losses: 2, otl: 1 }, "NYR": { wins: 2, losses: 1, otl: 0 }, "WSH": { wins: 1, losses: 1, otl: 1 }, "NJ": { wins: 2, losses: 1, otl: 0 }, "NYI": { wins: 0, losses: 2, otl: 1 }, "PIT": { wins: 1, losses: 2, otl: 0 }, "CBJ": { wins: 1, losses: 2, otl: 0 } },
      "PIT": { "CAR": { wins: 1, losses: 2, otl: 0 }, "NYR": { wins: 1, losses: 1, otl: 1 }, "WSH": { wins: 2, losses: 1, otl: 0 }, "NJ": { wins: 1, losses: 1, otl: 1 }, "NYI": { wins: 1, losses: 2, otl: 0 }, "PHI": { wins: 2, losses: 1, otl: 0 }, "CBJ": { wins: 1, losses: 1, otl: 1 } },
      "SEA": { "VAN": { wins: 1, losses: 2, otl: 0 }, "VGK": { wins: 1, losses: 1, otl: 1 }, "LA": { wins: 1, losses: 1, otl: 1 }, "ANA": { wins: 1, losses: 2, otl: 0 }, "CGY": { wins: 1, losses: 2, otl: 0 }, "EDM": { wins: 0, losses: 2, otl: 1 }, "SJ": { wins: 2, losses: 1, otl: 0 } },
      "SJ": { "ANA": { wins: 2, losses: 1, otl: 0 }, "LA": { wins: 1, losses: 2, otl: 0 }, "VGK": { wins: 1, losses: 2, otl: 0 }, "SEA": { wins: 1, losses: 2, otl: 0 }, "VAN": { wins: 1, losses: 1, otl: 1 }, "CGY": { wins: 1, losses: 2, otl: 0 }, "EDM": { wins: 1, losses: 2, otl: 0 } },
      "STL": { "COL": { wins: 0, losses: 3, otl: 0 }, "DAL": { wins: 1, losses: 2, otl: 0 }, "MIN": { wins: 1, losses: 2, otl: 0 }, "WPG": { wins: 1, losses: 1, otl: 1 }, "NSH": { wins: 1, losses: 2, otl: 0 }, "CHI": { wins: 2, losses: 1, otl: 0 }, "UTA": { wins: 1, losses: 1, otl: 1 } },
      "TB": { "FLA": { wins: 2, losses: 1, otl: 0 }, "BOS": { wins: 2, losses: 1, otl: 0 }, "TOR": { wins: 2, losses: 0, otl: 1 }, "MTL": { wins: 1, losses: 1, otl: 1 }, "BUF": { wins: 2, losses: 1, otl: 0 }, "OTT": { wins: 1, losses: 1, otl: 1 }, "DET": { wins: 2, losses: 1, otl: 0 } },
      "TOR": { "BOS": { wins: 1, losses: 2, otl: 0 }, "TB": { wins: 0, losses: 2, otl: 1 }, "FLA": { wins: 1, losses: 2, otl: 0 }, "MTL": { wins: 2, losses: 1, otl: 0 }, "BUF": { wins: 2, losses: 1, otl: 0 }, "OTT": { wins: 2, losses: 1, otl: 0 }, "DET": { wins: 2, losses: 1, otl: 0 } },
      "UTA": { "COL": { wins: 1, losses: 2, otl: 0 }, "DAL": { wins: 1, losses: 1, otl: 1 }, "MIN": { wins: 1, losses: 1, otl: 1 }, "WPG": { wins: 2, losses: 1, otl: 0 }, "STL": { wins: 1, losses: 1, otl: 1 }, "NSH": { wins: 2, losses: 1, otl: 0 }, "CHI": { wins: 2, losses: 1, otl: 0 } },
      "VAN": { "SEA": { wins: 2, losses: 1, otl: 0 }, "VGK": { wins: 1, losses: 1, otl: 1 }, "LA": { wins: 1, losses: 2, otl: 0 }, "ANA": { wins: 2, losses: 1, otl: 0 }, "CGY": { wins: 1, losses: 1, otl: 1 }, "EDM": { wins: 1, losses: 2, otl: 0 }, "SJ": { wins: 1, losses: 1, otl: 1 } },
      "VGK": { "LA": { wins: 2, losses: 1, otl: 0 }, "ANA": { wins: 1, losses: 1, otl: 1 }, "SJ": { wins: 2, losses: 1, otl: 0 }, "SEA": { wins: 1, losses: 1, otl: 1 }, "VAN": { wins: 1, losses: 1, otl: 1 }, "CGY": { wins: 2, losses: 1, otl: 0 }, "EDM": { wins: 1, losses: 1, otl: 1 } },
      "WSH": { "CAR": { wins: 0, losses: 2, otl: 1 }, "NYR": { wins: 1, losses: 1, otl: 1 }, "NJ": { wins: 1, losses: 1, otl: 1 }, "NYI": { wins: 2, losses: 1, otl: 0 }, "PIT": { wins: 1, losses: 2, otl: 0 }, "PHI": { wins: 1, losses: 1, otl: 1 }, "CBJ": { wins: 2, losses: 1, otl: 0 } },
      "WPG": { "COL": { wins: 1, losses: 2, otl: 0 }, "DAL": { wins: 0, losses: 2, otl: 1 }, "MIN": { wins: 1, losses: 2, otl: 0 }, "STL": { wins: 1, losses: 1, otl: 1 }, "NSH": { wins: 1, losses: 2, otl: 0 }, "CHI": { wins: 1, losses: 2, otl: 0 }, "UTA": { wins: 1, losses: 2, otl: 0 } }
    };

    // V7.0 Helper: Check if game is back-to-back based on dates
    function isBackToBack(currentDate, previousDate) {
      if (!previousDate || !currentDate) return false;
      const curr = new Date(currentDate);
      const prev = new Date(previousDate);
      const diffDays = (curr - prev) / (1000 * 60 * 60 * 24);
      return diffDays <= 1;
    }

    // V7.0 Helper: Calculate head-to-head adjustment (Â±5% max)
    function calculateH2HAdjustment(teamA, teamB) {
      const record = headToHeadData[teamA]?.[teamB];
      if (!record) return 0;
      const totalGames = record.wins + record.losses + record.otl;
      if (totalGames < 2) return 0;
      const winPct = (record.wins + record.otl * 0.5) / totalGames;
      const regressionFactor = Math.min(1, totalGames / 4);
      const adjustedWinPct = 0.5 + (winPct - 0.5) * regressionFactor;
      return (adjustedWinPct - 0.5) * 0.10;
    }

    // V7.0 Helper: Continuous HD save percentage scoring
    function calculateHDSavePctScore(hdSavePct, maxPoints = 2) {
      const baseline = 0.82;
      const elite = 0.85;
      const normalized = (hdSavePct - baseline) / (elite - baseline);
      return maxPoints * Math.max(-1, Math.min(1, normalized));
    }

    // V7.0 Helper: Parse oneGoalRecord string ("12-5-2") into win percentage
    function parseOneGoalRecord(recordStr) {
      if (!recordStr) return 0.5;
      const parts = recordStr.split('-').map(Number);
      if (parts.length !== 3 || parts.some(isNaN)) return 0.5;
      const [wins, losses, otl] = parts;
      const totalGames = wins + losses + otl;
      if (totalGames === 0) return 0.5;
      return (wins + otl * 0.5) / totalGames;
    }

    // V6.0: Sigmoid scoring with metric-specific midpoints
    function sigmoidScore(rank, maxPoints, metric = 'default') {
      const params = SIGMOID_PARAMS[metric] || SIGMOID_PARAMS.default;
      const steepness = params.k;
      const midpoint = params.midpoint;
      return maxPoints / (1 + Math.exp(steepness * (rank - midpoint)));
    }

    // V6.0: Continuous PDO scoring (replaces bucket-based)
    function calculatePDOScore(pdo, maxPoints = 3) {
      if (pdo >= 100 && pdo <= 101.5) return maxPoints;
      if (pdo > 101.5) return maxPoints * Math.exp(-0.3 * (pdo - 101.5));
      return maxPoints * Math.exp(-0.15 * (100 - pdo));
    }

    // V6.0: Continuous form multiplier with mean-reversion
    function calculateFormMultiplier(team) {
      const baseForm = team.recentXgf;
      const seasonAvg = team.xgf;
      const meanReversionFactor = 1 - (Math.abs(baseForm - 50) / 100) * 0.3;
      const formDelta = baseForm - seasonAvg;
      const sustainabilityDiscount = formDelta > 5 ? 0.85 : formDelta > 3 ? 0.92 : 1.0;
      let multiplier;
      if (baseForm >= 55) {
        multiplier = 1.20 + (baseForm - 55) * 0.02;  // Blazing hot
      } else if (baseForm >= 52) {
        multiplier = 1.0 + (baseForm - 52) * 0.067;  // Hot
      } else if (baseForm >= 47) {
        multiplier = 1.0;  // Stable (47-51.9)
      } else if (baseForm >= 45) {
        multiplier = 0.75 + (baseForm - 40) * 0.036;  // Cold (45-46.9)
      } else {
        multiplier = 0.60 + (baseForm - 35) * 0.015;  // Freezing (<45)
      }
      return Math.max(0.6, Math.min(1.35, multiplier * sustainabilityDiscount * meanReversionFactor));
    }

    // V6.0: Depth scoring with diminishing returns
    function calculateDepthScore(depth20g, maxPoints = 6) {
      const values = [1.5, 1.3, 1.1, 0.9, 0.7, 0.5];
      let score = 0;
      for (let i = 0; i < Math.min(depth20g, values.length); i++) score += values[i];
      if (depth20g > values.length) score += (depth20g - values.length) * 0.3;
      return Math.min(maxPoints, score);
    }

    // Calculate team score with V4.0 continuous scoring
    function calculateScore(team, allTeams) {
      const gd = team.gf - team.ga;
      const xgd = team.xgf - team.xga;
      const gsax = team.gsax !== undefined ? team.gsax : ((team.xga - 50) * team.gp * -0.1);
      const ppPct = team.ppPct !== undefined ? team.ppPct : 18.0; // Default league average

      // Calculate rankings for all metrics
      const sorted = {
        hdcf: [...allTeams].sort((a, b) => b.hdcf - a.hdcf),
        xgd: [...allTeams].sort((a, b) => (b.xgf - b.xga) - (a.xgf - a.xga)),
        cf: [...allTeams].sort((a, b) => b.cf - a.cf),
        xga: [...allTeams].sort((a, b) => a.xga - b.xga), // Lower is better
        pk: [...allTeams].sort((a, b) => b.pkPct - a.pkPct),
        pp: [...allTeams].sort((a, b) => (b.ppPct || 18) - (a.ppPct || 18)),
        gd: [...allTeams].sort((a, b) => (b.gf - b.ga) - (a.gf - a.ga)),
        ga: [...allTeams].sort((a, b) => a.ga - b.ga), // Lower is better
        weight: [...allTeams].sort((a, b) => b.weight - a.weight),
        depth: [...allTeams].sort((a, b) => b.depth20g - a.depth20g),
        recentXgf: [...allTeams].sort((a, b) => b.recentXgf - a.recentXgf),
        pdo: [...allTeams].sort((a, b) => b.pdo - a.pdo),
        gsax: [...allTeams].sort((a, b) => {
          const gsaxA = a.gsax !== undefined ? a.gsax : ((a.xga - 50) * a.gp * -0.1);
          const gsaxB = b.gsax !== undefined ? b.gsax : ((b.xga - 50) * b.gp * -0.1);
          return gsaxB - gsaxA;
        }),
        goalieSvPct: [...allTeams].sort((a, b) => (b.goalieSvPct || 0.900) - (a.goalieSvPct || 0.900)),
      };

      const rankings = {
        hdcf: sorted.hdcf.findIndex(t => t.team === team.team) + 1,
        xgd: sorted.xgd.findIndex(t => t.team === team.team) + 1,
        cf: sorted.cf.findIndex(t => t.team === team.team) + 1,
        xga: sorted.xga.findIndex(t => t.team === team.team) + 1,
        pk: sorted.pk.findIndex(t => t.team === team.team) + 1,
        pp: sorted.pp.findIndex(t => t.team === team.team) + 1,
        gd: sorted.gd.findIndex(t => t.team === team.team) + 1,
        ga: sorted.ga.findIndex(t => t.team === team.team) + 1,
        weight: sorted.weight.findIndex(t => t.team === team.team) + 1,
        depth: sorted.depth.findIndex(t => t.team === team.team) + 1,
        recentXgf: sorted.recentXgf.findIndex(t => t.team === team.team) + 1,
        pdo: sorted.pdo.findIndex(t => t.team === team.team) + 1,
        gsax: sorted.gsax.findIndex(t => t.team === team.team) + 1,
        goalieSvPct: sorted.goalieSvPct.findIndex(t => t.team === team.team) + 1,
      };

      let score = 0;

      // =====================================================
      // V5.0 SIGMOID SCORING - Continuous with metric-specific curves
      // =====================================================

      // HDCF% (12%) - Primary offensive quality
      score += sigmoidScore(rankings.hdcf, 12, 'hdcf');

      // xGD (10%) - Process metric, reduced from 11%
      score += sigmoidScore(rankings.xgd, 10, 'xgd');

      // xGA (10%) - Defense, increased importance
      score += sigmoidScore(rankings.xga, 10, 'xga');

      // GSAx (11%) - Goaltending excellence (reduced 1% for V7.0 additions)
      let gsaxScore = sigmoidScore(rankings.gsax, 11, 'gsax');
      // V7.0: HD Save% continuous scoring
      if (team.hdSavePct) {
        const hdBonus = calculateHDSavePctScore(team.hdSavePct, 2);
        gsaxScore += hdBonus;
      }
      score += gsaxScore;

      // Recent Form (7%) - Momentum matters with SYMMETRIC multipliers (V5.0 fix)
      let formStatus = 'stable';
      let formPts = sigmoidScore(rankings.recentXgf, 7, 'recentXgf');

      // V5.0: Symmetric form multipliers - hot teams get bonus, cold get penalty
      if (team.recentXgf >= 55 && rankings.recentXgf <= 5) {
        formStatus = 'blazing';
        formPts *= 1.30; // +30% bonus for blazing hot teams
      } else if (team.recentXgf >= 53 && rankings.recentXgf <= 10) {
        formStatus = 'hot';
        formPts *= 1.15; // +15% bonus for hot teams
      } else if (team.recentXgf >= 51 && rankings.recentXgf <= 12) {
        formStatus = 'warm';
        // No bonus/penalty for warm teams
      } else if (team.recentXgf < 47 || rankings.recentXgf >= 25) {
        formStatus = 'cold';
        formPts *= 0.80; // -20% penalty for cold teams
      } else {
        formStatus = 'stable';
      }
      if (rankings.recentXgf >= 28 || team.recentXgf < 45) {
        formStatus = 'freezing';
        formPts *= 0.60; // -40% penalty for freezing teams
      }
      score += formPts;

      // PK% (8%) - Critical in playoffs
      score += sigmoidScore(rankings.pk, 8, 'pk');

      // PP% (6%) - Special teams balance
      score += sigmoidScore(rankings.pp, 6, 'pp');

      // Depth (6%) - V5.0: Smooth continuous formula instead of cliff at 4â†’3
      // Old: 4 scorers = 5pts, 3 scorers = 3.5pts (30% drop cliff)
      // New: Continuous scaling with diminishing returns
      const depthPts = Math.min(6, 0.5 + (team.depth20g * 1.375));
      score += depthPts;

      // CF% (5%) - Reduced, HDCF captures quality better
      score += sigmoidScore(rankings.cf, 5, 'cf');

      // PDO (4%) - Reduced, use as uncertainty indicator
      let pdoPts = 0;
      if (team.pdo >= 100 && team.pdo <= 101.5) pdoPts = 4; // Ideal range
      else if (team.pdo >= 99 && team.pdo < 100) pdoPts = 3; // Slightly unlucky
      else if (team.pdo > 101.5 && team.pdo <= 103) pdoPts = 2; // Hot but sustainable
      else if (team.pdo > 103) pdoPts = 0.5; // Regression risk
      else pdoPts = 1; // Cold
      score += pdoPts;

      // Star Power (5%) - V5.0: Continuous scoring instead of binary 0/5
      // Old: hasStar = 5pts, no star = 0pts (treats McDavid same as borderline stars)
      // New: Use starPPG for continuous scaling
      let starPts = 0;
      if (team.starPPG && team.starPPG > 0) {
        // Scale: 0.7 PPG = 0pts, 1.5 PPG = 5pts (max)
        starPts = Math.min(5, Math.max(0, (team.starPPG - 0.7) * 6.25));
      } else if (team.hasStar) {
        // Fallback to binary if starPPG not available
        starPts = 5;
      }
      score += starPts;

      // GD (2%) - Further reduced from 3% (only 17% of GD leaders won Cup)
      score += sigmoidScore(rankings.gd, 2, 'gd');

      // GA (4%) - Goals against
      score += sigmoidScore(rankings.ga, 4, 'ga');

      // Weight (4%) - Unchanged
      score += sigmoidScore(rankings.weight, 4, 'weight');

      // Playoff Variance Factor (5%)
      // Teams with balanced metrics are more consistent
      const consistencyScore = calculateConsistency(rankings);
      score += consistencyScore * 5;

      // V5.0: Playoff Experience Factor (4%)
      // Research shows teams with recent Cup Final experience significantly outperform
      let playoffExpPts = 0;
      if (team.playoffExp) {
        // Cup win in last 5 years: +2.0 pts
        if (team.playoffExp.cupWinLast5) playoffExpPts += 2.0;
        // Cup Final in last 3 years: +1.5 pts
        if (team.playoffExp.cupFinalLast3) playoffExpPts += 1.5;
        // Conference Final in last 3 years: +1.0 pts
        if (team.playoffExp.confFinalLast3) playoffExpPts += 1.0;
        // +0.25 pts per playoff round won in last 3 years (max +2.0)
        if (team.playoffExp.playoffRoundsLast3) {
          playoffExpPts += Math.min(2.0, team.playoffExp.playoffRoundsLast3 * 0.25);
        }
        // Cap at 4 points total
        playoffExpPts = Math.min(4, playoffExpPts);
      }
      score += playoffExpPts;

      // V5.0: Schedule Strength Factor (2%)
      // Harder remaining schedule = slight bonus (shows true quality)
      const schedStrength = calculateScheduleStrength(team, allTeams);
      score += schedStrength * 2;

      // V5.0: Trade Deadline Adjustment
      // Applied when significant trades occur
      const tradeAdj = getTradeDeadlineAdjustment(team.team);
      score += tradeAdj;

      // V7.0: Coaching Factor (3%)
      // Research shows coaching correlates with playoff success
      let coachingPts = 0;
      if (team.coachScore !== undefined) {
        coachingPts = team.coachScore * 3;
      } else {
        // Default neutral coaching (0.5 = average)
        coachingPts = 0.5 * 3;
      }
      score += coachingPts;

      // V7.0: Clutch Performance (2%)
      // Teams that win close games demonstrate mental toughness
      let clutchPts = 0;
      if (team.oneGoalRecord) {
        const oneGoalWinPct = parseOneGoalRecord(team.oneGoalRecord);
        // Scale: 0.5 (average) = 1pt, 0.7 (elite) = 2pts, 0.3 (poor) = 0pts
        clutchPts = Math.max(0, Math.min(2, (oneGoalWinPct - 0.3) * 5));
      } else {
        clutchPts = 1; // Default to average
      }
      score += clutchPts;

      // Round to 1 decimal
      score = Math.round(score * 10) / 10;

      // Injury adjustment
      const injuryData = calculateInjuryAdjustment(team.team);
      const adjustedScore = Math.max(0, score + injuryData.adjustment);

      // V7.1: Use pre-calculated weight from JSON if available, otherwise use adjustedScore
      // Weight scale: 100-300 (200 = average), calculated from HDCF%, CF%, PDO, PP%, PK%, GSAx
      const finalScore = team.weight && team.weight !== 200 ? team.weight : adjustedScore;

      // Tier based on weight (V7.1 thresholds for 100-300 scale)
      let tier;
      if (finalScore >= 230) tier = 'elite';
      else if (finalScore >= 200) tier = 'contender';
      else if (finalScore >= 170) tier = 'bubble';
      else tier = 'longshot';

      return {
        score: finalScore,
        baseScore: score,
        rankings,
        tier,
        gd,
        xgd,
        ppPct,
        formStatus,
        gsax,
        injuryData,
      };
    }

    // V6.0: Calculate consistency - rewards elite ceilings, not just balance
    function calculateConsistency(rankings) {
      const keyMetrics = [rankings.hdcf, rankings.xgd, rankings.xga, rankings.gsax, rankings.pk];
      const eliteCount = keyMetrics.filter(r => r <= 5).length;
      const weaknessCount = keyMetrics.filter(r => r >= 23).length;

      // Elite ceiling approach
      if (eliteCount >= 3 && weaknessCount === 0) return 1.0;
      if (eliteCount >= 2 && weaknessCount <= 1) return 0.9;
      if (eliteCount >= 2) return 0.8;
      if (eliteCount >= 1 && weaknessCount <= 1) return 0.7;

      const avg = keyMetrics.reduce((a, b) => a + b, 0) / keyMetrics.length;
      const variance = keyMetrics.reduce((sum, r) => sum + Math.pow(r - avg, 2), 0) / keyMetrics.length;
      const stdDev = Math.sqrt(variance);

      if (avg > 16 && stdDev < 5) return 0.5;  // Consistently mediocre = penalty
      if (stdDev < 5) return 0.6;
      if (stdDev < 8) return 0.5;
      if (stdDev < 12) return 0.4;
      return 0.2;
    }

    // V5.0: Calculate schedule strength based on remaining opponents
    function calculateScheduleStrength(team, allTeams) {
      // If no remaining schedule data, return neutral score
      const remainingGames = 82 - team.gp;
      if (remainingGames <= 0) return 0.5;

      // Calculate average opponent score from conference teams (simplified)
      // In real implementation, this would use actual schedule data
      const confTeams = allTeams.filter(t => t.conf === team.conf && t.team !== team.team);
      const avgConfScore = confTeams.reduce((sum, t) => {
        // Use team score if already calculated, otherwise estimate
        const score = t.score || 50;
        return sum + score;
      }, 0) / confTeams.length;

      // Normalize to 0-1 range (higher = harder schedule)
      // Average score ~60, range 30-90
      return Math.min(1, Math.max(0, (avgConfScore - 40) / 40));
    }

    // V5.0: Trade deadline adjustment system
    const TRADE_DEADLINE_ADJUSTMENTS = {
      // Format: { team: adjustment, note: description }
      // Update when significant trades happen
      // Example: { 'TOR': 2, note: 'Acquired elite defenseman' }
    };

    function getTradeDeadlineAdjustment(teamAbbr) {
      const adj = TRADE_DEADLINE_ADJUSTMENTS[teamAbbr];
      return adj ? adj : 0;
    }

    // V5.0: Enhanced physicality scoring
    function calculatePhysicalityScore(team, rankings) {
      // Use hitsPerGame and blocksPerGame if available
      if (team.hitsPerGame && team.blocksPerGame) {
        // League averages: hits ~22, blocks ~14
        const hitsScore = (team.hitsPerGame - 18) / 10; // 0-1 range roughly
        const blocksScore = (team.blocksPerGame - 11) / 6;
        // Combined physicality with weights
        const physical = (hitsScore * 0.6 + blocksScore * 0.4);
        return Math.min(1, Math.max(0, (physical + 0.5) / 1.5));
      }
      // Fallback to weight ranking
      return 1 - (rankings.weight / 32);
    }

    // Process all teams
    let processedTeams = teamsData.map(t => ({
      ...t,
      ...calculateScore(t, teamsData)
    })).sort((a, b) => b.score - a.score);

    // =====================================================
    // V6.0 MONTE CARLO SIMULATION
    // Improvements:
    // - 100,000 simulations (up from 50K) for better Cup probability tails
    // - Soft cap on home ice (not hard cap at 0.85)
    // - Series momentum factor
    // - Uses actual team regWins ratio for OT tracking
    // =====================================================
    const TOTAL_GAMES = 82;
    const SIMULATION_RUNS = 100000;
    const HOME_ICE_ADVANTAGE = 0.04;
    const OT_PROBABILITY = 0.08;
    const PLAYOFF_VARIANCE = 0.12;
    const BACK_TO_BACK_PENALTY = 0.04; // V7.0: -4% win probability for B2B games

    // V6.0: Win probability with soft cap (not hard cap at 0.85)
    function calculateWinProbability(teamAScore, teamBScore, isHome = false, isPlayoffs = false) {
      const scoreDiff = teamAScore - teamBScore;
      const k = isPlayoffs ? 0.035 : 0.04;
      let baseProb = 1 / (1 + Math.exp(-k * scoreDiff));

      if (isHome) {
        const homeBoost = HOME_ICE_ADVANTAGE;
        const newProb = baseProb + homeBoost;
        if (newProb > 0.80) {
          baseProb = 0.80 + (newProb - 0.80) * 0.5; // Diminishing returns above 80%
        } else {
          baseProb = newProb;
        }
      }

      if (isPlayoffs) {
        baseProb = baseProb * (1 - PLAYOFF_VARIANCE) + 0.5 * PLAYOFF_VARIANCE;
      }

      return Math.min(0.92, Math.max(0.08, baseProb)); // Ensure upset potential
    }

    // V6.0: Simulate series with momentum
    function simulateSeriesV6(team1, team2, team1HasHomeIce) {
      let wins1 = 0, wins2 = 0;
      let momentum1 = 0, momentum2 = 0;
      const homeTeams = [team1, team1, team2, team2, team1, team2, team1];

      for (let game = 0; game < 7 && wins1 < 4 && wins2 < 4; game++) {
        const isTeam1Home = team1HasHomeIce ? homeTeams[game] === team1 : homeTeams[game] === team2;
        let winProb = calculateWinProbability(team1.score, team2.score, isTeam1Home, true);
        winProb += momentum1 * 0.01 - momentum2 * 0.01;
        if (wins2 === 3 && wins1 < 3) winProb += 0.02;
        if (wins1 === 3 && wins2 < 3) winProb -= 0.02;
        winProb = Math.min(0.90, Math.max(0.10, winProb));

        if (Math.random() < winProb) {
          wins1++;
          momentum1 = Math.min(2, momentum1 + 1);
          momentum2 = 0;
        } else {
          wins2++;
          momentum2 = Math.min(2, momentum2 + 1);
          momentum1 = 0;
        }
      }
      return wins1 > wins2 ? team1 : team2;
    }

    // V5.0: NHL Tiebreaker system
    function compareTiebreaker(a, b) {
      // 1. Regulation wins (regWins field)
      const regWinsA = a.simRegWins || a.regWins || Math.floor(a.simWins * 0.75);
      const regWinsB = b.simRegWins || b.regWins || Math.floor(b.simWins * 0.75);
      if (regWinsA !== regWinsB) return regWinsB - regWinsA;

      // 2. ROW (Regulation + OT wins, excludes shootouts)
      const rowA = regWinsA + (a.simOTWins || 2);
      const rowB = regWinsB + (b.simOTWins || 2);
      if (rowA !== rowB) return rowB - rowA;

      // 3. Total wins
      const winsA = a.simWins || a.w;
      const winsB = b.simWins || b.w;
      if (winsA !== winsB) return winsB - winsA;

      // 4. Goal differential
      const gdA = a.simGD || (a.gf - a.ga);
      const gdB = b.simGD || (b.gf - b.ga);
      return gdB - gdA;
    }

    // V5.0: Correct NHL playoff seeding
    function determinePlayoffSeeding(confTeams) {
      // Sort by points first, then tiebreakers
      const sorted = [...confTeams].sort((a, b) => {
        if (b.finalPts !== a.finalPts) return b.finalPts - a.finalPts;
        return compareTiebreaker(a, b);
      });

      // Get divisions in this conference
      const divisions = [...new Set(sorted.map(t => t.div))];
      const playoffTeams = [];
      const divisionWinners = [];

      // Step 1: Division winners get seeds 1-3 (sorted by points)
      divisions.forEach(div => {
        const divTeams = sorted.filter(t => t.div === div);
        if (divTeams.length > 0) {
          divisionWinners.push(divTeams[0]);
        }
      });

      // Sort division winners by points for seeding
      divisionWinners.sort((a, b) => {
        if (b.finalPts !== a.finalPts) return b.finalPts - a.finalPts;
        return compareTiebreaker(a, b);
      });

      // Seeds 1-3 are division winners
      divisionWinners.forEach((team, idx) => {
        playoffTeams.push({ ...team, seed: idx + 1, isDivWinner: true });
      });

      // Step 2: Wild cards (next best teams not already in)
      const divWinnerTeams = divisionWinners.map(t => t.team);
      const wildCardCandidates = sorted.filter(t => !divWinnerTeams.includes(t.team));

      // Add wild cards (seeds 4-5, then remaining slots 6-8)
      let seed = 4;
      for (let i = 0; i < wildCardCandidates.length && playoffTeams.length < 8; i++) {
        playoffTeams.push({
          ...wildCardCandidates[i],
          seed: seed,
          isDivWinner: false,
          isWildCard: seed <= 5
        });
        seed++;
      }

      return playoffTeams;
    }

    // V7.0: Simulate a best-of-7 series with H2H adjustment and momentum
    function simulateSeries(team1, team2, team1HomeIce) {
      let wins1 = 0, wins2 = 0;
      let momentum1 = 0, momentum2 = 0;
      // 2-2-1-1-1 format
      const homeTeams = [team1, team1, team2, team2, team1, team2, team1];

      // V7.0: Calculate head-to-head adjustment for this matchup (Â±5% max)
      const h2hAdjustment = calculateH2HAdjustment(team1.team, team2.team);

      for (let game = 0; game < 7 && wins1 < 4 && wins2 < 4; game++) {
        const isTeam1Home = homeTeams[game] === team1;
        let winProb = calculateWinProbability(
          team1.score,
          team2.score,
          isTeam1Home ? team1HomeIce : !team1HomeIce,
          true // isPlayoffs
        );

        // V7.0: Apply H2H adjustment based on season series
        winProb += h2hAdjustment;

        // V6.0: Add momentum factor (consecutive wins boost)
        winProb += momentum1 * 0.01 - momentum2 * 0.01;

        // Elimination desperation: team facing elimination gets slight boost
        if (wins2 === 3 && wins1 < 3) winProb += 0.02;
        if (wins1 === 3 && wins2 < 3) winProb -= 0.02;

        winProb = Math.min(0.90, Math.max(0.10, winProb));

        if (Math.random() < winProb) {
          wins1++;
          momentum1 = Math.min(2, momentum1 + 1);
          momentum2 = 0;
        } else {
          wins2++;
          momentum2 = Math.min(2, momentum2 + 1);
          momentum1 = 0;
        }
      }

      return wins1 > wins2 ? team1 : team2;
    }

    // V5.0: Simulate full playoff bracket
    function simulatePlayoffBracket(eastTeams, westTeams) {
      // Round 1: Division matchups
      // Bracket: 1v8(WC2), 2v7(WC1), 3v6, 4(DivWinner)v5
      // Simplified: 1v8, 2v7, 3v6, 4v5 within conference

      function playRound(teams) {
        const winners = [];
        const n = teams.length;
        for (let i = 0; i < n / 2; i++) {
          const higher = teams[i];
          const lower = teams[n - 1 - i];
          const winner = simulateSeries(higher, lower, true); // Higher seed has home ice
          winners.push(winner);
        }
        return winners;
      }

      // Conference playoffs
      let eastBracket = eastTeams.slice(0, 8);
      let westBracket = westTeams.slice(0, 8);

      // Round 1
      eastBracket = playRound(eastBracket);
      westBracket = playRound(westBracket);

      // Round 2 (Conference Semis)
      eastBracket = playRound(eastBracket);
      westBracket = playRound(westBracket);

      // Conference Finals
      const eastChamp = simulateSeries(eastBracket[0], eastBracket[1], true);
      const westChamp = simulateSeries(westBracket[0], westBracket[1], true);

      // Stanley Cup Final
      const cupWinner = simulateSeries(eastChamp, westChamp,
        eastChamp.finalPts >= westChamp.finalPts);

      return {
        eastChamp: eastChamp.team,
        westChamp: westChamp.team,
        cupWinner: cupWinner.team
      };
    }

    function runPlayoffSimulation(teams, numSimulations = SIMULATION_RUNS) {
      const results = {};
      teams.forEach(team => {
        results[team.team] = {
          playoffAppearances: 0,
          divisionWins: 0,
          conferenceWins: 0,
          totalPoints: 0,
          cupWins: 0,
          confFinalAppearances: 0,
        };
      });

      const batchSize = 10000;
      const numBatches = Math.ceil(numSimulations / batchSize);

      for (let batch = 0; batch < numBatches; batch++) {
        const simsInBatch = Math.min(batchSize, numSimulations - batch * batchSize);

        for (let sim = 0; sim < simsInBatch; sim++) {
          const standings = {};
          teams.forEach(team => {
            standings[team.team] = {
              ...team,
              simPts: team.pts,
              simWins: team.w,
              simRegWins: team.regWins || Math.floor(team.w * 0.75),
              simGD: team.gf - team.ga
            };
          });

          // V7.0: Simulate remaining games using ACTUAL SCHEDULE with B2B fatigue
          const gamesToSimulate = [];
          const processedMatchups = new Set();

          teams.forEach(team => {
            const schedule = scheduleData.teams[team.team]?.remaining || [];
            schedule.forEach(game => {
              const gameKey = [team.team, game.opponent].sort().join('-') + '-' + game.date;
              if (!processedMatchups.has(gameKey)) {
                processedMatchups.add(gameKey);
                gamesToSimulate.push({
                  homeTeam: game.home ? team.team : game.opponent,
                  awayTeam: game.home ? game.opponent : team.team,
                  date: game.date
                });
              }
            });
          });

          gamesToSimulate.sort((a, b) => new Date(a.date) - new Date(b.date));
          const lastGameDate = {};

          // V7.0: Simulate each game once (synchronized results)
          gamesToSimulate.forEach(game => {
            const homeTeamData = teams.find(t => t.team === game.homeTeam);
            const awayTeamData = teams.find(t => t.team === game.awayTeam);
            if (!homeTeamData || !awayTeamData) return;

            let homeWinProb = calculateWinProbability(homeTeamData.score, awayTeamData.score, true, false);

            // V7.0: Apply B2B penalty
            if (isBackToBack(game.date, lastGameDate[game.homeTeam])) homeWinProb -= BACK_TO_BACK_PENALTY;
            if (isBackToBack(game.date, lastGameDate[game.awayTeam])) homeWinProb += BACK_TO_BACK_PENALTY;

            homeWinProb = Math.max(0.15, Math.min(0.85, homeWinProb));

            const homeRegWinRatio = homeTeamData.w > 0 ? (homeTeamData.regWins || homeTeamData.w * 0.75) / homeTeamData.w : 0.75;
            const awayRegWinRatio = awayTeamData.w > 0 ? (awayTeamData.regWins || awayTeamData.w * 0.75) / awayTeamData.w : 0.75;
            const random = Math.random();

            if (random < homeWinProb) {
              standings[game.homeTeam].simPts += 2;
              standings[game.homeTeam].simWins++;
              if (random < homeWinProb * homeRegWinRatio) standings[game.homeTeam].simRegWins++;
              standings[game.homeTeam].simGD += 1;
              standings[game.awayTeam].simGD -= 1;
            } else if (random < homeWinProb + OT_PROBABILITY) {
              standings[game.awayTeam].simPts += 2;
              standings[game.awayTeam].simWins++;
              standings[game.homeTeam].simPts += 1;
              standings[game.awayTeam].simGD += 1;
              standings[game.homeTeam].simGD -= 1;
            } else {
              standings[game.awayTeam].simPts += 2;
              standings[game.awayTeam].simWins++;
              if (random > 1 - (1 - homeWinProb - OT_PROBABILITY) * awayRegWinRatio) standings[game.awayTeam].simRegWins++;
              standings[game.awayTeam].simGD += 1;
              standings[game.homeTeam].simGD -= 1;
            }

            lastGameDate[game.homeTeam] = game.date;
            lastGameDate[game.awayTeam] = game.date;
          });

          // Fallback for teams with incomplete schedule data
          teams.forEach(team => {
            const scheduleGames = (scheduleData.teams[team.team]?.remaining || []).length;
            const actualRemaining = TOTAL_GAMES - team.gp;
            const gamesLeftToSim = actualRemaining - scheduleGames;
            if (gamesLeftToSim > 0) {
              const regWinRatio = team.w > 0 ? (team.regWins || team.w * 0.75) / team.w : 0.75;
              for (let g = 0; g < gamesLeftToSim; g++) {
                const confTeams = teams.filter(t => t.conf === team.conf && t.team !== team.team);
                const opponent = confTeams[Math.floor(Math.random() * confTeams.length)];
                const isHome = g % 2 === 0;
                const winProb = calculateWinProbability(team.score, opponent.score, isHome);
                const random = Math.random();
                if (random < winProb) {
                  standings[team.team].simPts += 2;
                  standings[team.team].simWins++;
                  if (random < winProb * regWinRatio) standings[team.team].simRegWins++;
                  standings[team.team].simGD += 1;
                } else if (random < winProb + OT_PROBABILITY) {
                  standings[team.team].simPts += 1;
                }
              }
            }
          });

          // V5.0: Correct playoff seeding per conference
          const playoffResults = {};
          ['East', 'West'].forEach(conf => {
            const confTeams = teams
              .filter(t => t.conf === conf)
              .map(t => ({
                ...t,
                finalPts: standings[t.team].simPts,
                simWins: standings[t.team].simWins,
                simRegWins: standings[t.team].simRegWins,
                simGD: standings[t.team].simGD
              }));

            const playoffTeams = determinePlayoffSeeding(confTeams);
            playoffResults[conf] = playoffTeams;

            playoffTeams.forEach(team => {
              results[team.team].playoffAppearances++;
              if (team.isDivWinner) results[team.team].divisionWins++;
            });
          });

          // Simulate playoff bracket
          const bracketResult = simulatePlayoffBracket(
            playoffResults['East'],
            playoffResults['West']
          );

          results[bracketResult.eastChamp].confFinalAppearances++;
          results[bracketResult.westChamp].confFinalAppearances++;
          results[bracketResult.cupWinner].cupWins++;

          // Track first in conference
          if (playoffResults['East'].length > 0) {
            results[playoffResults['East'][0].team].conferenceWins++;
          }
          if (playoffResults['West'].length > 0) {
            results[playoffResults['West'][0].team].conferenceWins++;
          }

          teams.forEach(team => {
            results[team.team].totalPoints += standings[team.team].simPts;
          });
        }
      }

      // Calculate final probabilities
      teams.forEach(team => {
        const r = results[team.team];
        r.playoffPct = Math.round((r.playoffAppearances / numSimulations) * 1000) / 10;
        r.divisionPct = Math.round((r.divisionWins / numSimulations) * 1000) / 10;
        r.conferencePct = Math.round((r.conferenceWins / numSimulations) * 1000) / 10;
        r.cupPct = Math.round((r.cupWins / numSimulations) * 1000) / 10;
        r.confFinalPct = Math.round((r.confFinalAppearances / numSimulations) * 1000) / 10;
        r.avgFinalPoints = Math.round(r.totalPoints / numSimulations);

        const p = r.playoffAppearances / numSimulations;
        const marginOfError = 1.645 * Math.sqrt(p * (1 - p) / numSimulations);
        r.confidenceInterval = {
          low: Math.max(0, Math.round((p - marginOfError) * 1000) / 10),
          high: Math.min(100, Math.round((p + marginOfError) * 1000) / 10),
        };
      });

      return results;
    }

    // Monte Carlo simulation removed â€” using superhuman model predictions from dashboard_data.json
    // const playoffOdds = runPlayoffSimulation(processedTeams);
    let modelPredictions = {}; // Populated by loadTeamData() from dashboard_data.json

    // Helper functions
    function getRankClass(rank) {
      if (rank <= 5) return 'rank-good';
      if (rank <= 10) return 'rank-ok';
      if (rank <= 16) return 'rank-mid';
      return 'rank-bad';
    }

    function getFormClass(status) {
      return 'form-' + status;
    }

    function getFormIcon(status) {
      const icons = { blazing: 'ðŸ”¥ðŸ”¥', hot: 'ðŸ”¥', warm: 'ðŸ“ˆ', stable: 'âž¡ï¸', cold: 'ðŸ“‰', freezing: 'ðŸ¥¶' };
      return icons[status] || 'âž¡ï¸';
    }

    function getTierColor(tier) {
      const colors = {
        elite: 'var(--accent-elite)',
        contender: 'var(--accent-contender)',
        bubble: 'var(--accent-bubble)',
        longshot: 'var(--accent-longshot)'
      };
      return colors[tier];
    }

    // State
    let currentView = 'matrix';
    let currentConf = 'all';

    // Render functions
    function renderMatrix() {
      const tbody = document.getElementById('matrix-body');
      const teams = currentConf === 'all' ? processedTeams : processedTeams.filter(t => t.conf === currentConf);

      // V7.2: Simplified matrix showing core weighted metrics
      tbody.innerHTML = teams.map((team, idx) => {
        const pdo = team.pdo < 2 ? team.pdo * 100 : team.pdo;  // Handle ratio vs percentage
        const xgfPct = team.xgf || 50;
        const gd = team.gf - team.ga;

        return `
        <tr data-tier="${team.tier}">
          <td>${idx + 1}</td>
          <td class="team-cell">
            <div class="team-name">${team.name || team.team}</div>
            <div class="team-meta">${team.conf}</div>
          </td>
          <td class="score-cell" style="color: ${getTierColor(team.tier)}; font-weight: 700;">
            ${team.weight || team.score}
          </td>
          <td style="font-weight: 600;">${team.pts}</td>
          <td>${team.w}-${team.l}-${team.otl}</td>
          <td>
            <div class="stat-value">${team.hdcf.toFixed(1)}%</div>
            <span class="rank-badge ${getRankClass(team.rankings?.hdcf || 16)}">${team.rankings?.hdcf || '-'}</span>
          </td>
          <td>
            <div class="stat-value ${team.gsax > 0 ? 'stat-gsax' : team.gsax < -5 ? 'stat-negative' : ''}">${team.gsax > 0 ? '+' : ''}${team.gsax.toFixed(1)}</div>
            <span class="rank-badge ${getRankClass(team.rankings?.gsax || 16)}">${team.rankings?.gsax || '-'}</span>
          </td>
          <td>
            <div class="stat-value">${team.cf.toFixed(1)}%</div>
            <span class="rank-badge ${getRankClass(team.rankings?.cf || 16)}">${team.rankings?.cf || '-'}</span>
          </td>
          <td>
            <div class="stat-value stat-positive">${(team.ppPct || 18.0).toFixed(1)}%</div>
            <span class="rank-badge ${getRankClass(team.rankings?.pp || 16)}">${team.rankings?.pp || '-'}</span>
          </td>
          <td>
            <div class="stat-value">${team.pkPct.toFixed(1)}%</div>
            <span class="rank-badge ${getRankClass(team.rankings?.pk || 16)}">${team.rankings?.pk || '-'}</span>
          </td>
          <td>
            <div class="stat-value ${pdo >= 100 && pdo <= 101.5 ? 'stat-positive' : pdo > 103 ? 'stat-negative' : ''}">${pdo.toFixed(1)}</div>
            <span class="rank-badge ${getRankClass(team.rankings?.pdo || 16)}">${team.rankings?.pdo || '-'}</span>
          </td>
          <td>
            <div class="stat-value">${xgfPct.toFixed(1)}%</div>
          </td>
          <td>
            <div class="stat-value ${gd > 0 ? 'stat-positive' : gd < 0 ? 'stat-negative' : ''}">${gd > 0 ? '+' : ''}${gd}</div>
          </td>
        </tr>
      `}).join('');
    }

    function renderScatter() {
      const svg = document.getElementById('scatter-svg');
      const width = 750;
      const height = 520;
      const margin = { top: 40, right: 60, bottom: 50, left: 60 };
      const plotWidth = width - margin.left - margin.right;
      const plotHeight = height - margin.top - margin.bottom;

      // Scales
      const hdcfMin = 42, hdcfMax = 62;
      const xgdMin = -20, xgdMax = 20;

      const scaleX = (hdcf) => margin.left + ((hdcf - hdcfMin) / (hdcfMax - hdcfMin)) * plotWidth;
      const scaleY = (xgd) => margin.top + plotHeight - ((xgd - xgdMin) / (xgdMax - xgdMin)) * plotHeight;

      const midX = scaleX(50);
      const midY = scaleY(0);

      let svgContent = `
        <defs>
          <linearGradient id="eliteGrad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:rgba(16,185,129,0.15)"/>
            <stop offset="100%" style="stop-color:rgba(16,185,129,0.05)"/>
          </linearGradient>
          <linearGradient id="avoidGrad" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" style="stop-color:rgba(239,68,68,0.1)"/>
            <stop offset="100%" style="stop-color:rgba(239,68,68,0.03)"/>
          </linearGradient>
        </defs>

        <!-- Background -->
        <rect width="${width}" height="${height}" fill="var(--bg-card)" rx="12"/>

        <!-- Quadrants -->
        <rect x="${midX}" y="${margin.top}" width="${margin.left + plotWidth - midX}" height="${midY - margin.top}" fill="url(#eliteGrad)"/>
        <rect x="${margin.left}" y="${midY}" width="${midX - margin.left}" height="${margin.top + plotHeight - midY}" fill="url(#avoidGrad)"/>

        <!-- Quadrant labels -->
        <text x="${(midX + margin.left + plotWidth) / 2}" y="${(margin.top + midY) / 2}" fill="var(--accent-elite)" font-size="12" font-weight="600" text-anchor="middle" opacity="0.8">ELITE</text>
        <text x="${(margin.left + midX) / 2}" y="${(margin.top + midY) / 2}" fill="var(--accent-bubble)" font-size="11" font-weight="600" text-anchor="middle" opacity="0.6">REGRESSION RISK</text>
        <text x="${(midX + margin.left + plotWidth) / 2}" y="${(midY + margin.top + plotHeight) / 2}" fill="var(--accent-contender)" font-size="11" font-weight="600" text-anchor="middle" opacity="0.6">UNDERVALUED</text>
        <text x="${(margin.left + midX) / 2}" y="${(midY + margin.top + plotHeight) / 2}" fill="var(--accent-longshot)" font-size="11" font-weight="600" text-anchor="middle" opacity="0.6">AVOID</text>

        <!-- Grid lines -->
        <line x1="${midX}" y1="${margin.top}" x2="${midX}" y2="${margin.top + plotHeight}" stroke="var(--border-color)" stroke-width="2"/>
        <line x1="${margin.left}" y1="${midY}" x2="${margin.left + plotWidth}" y2="${midY}" stroke="var(--border-color)" stroke-width="2"/>

        <!-- Axes -->
        <line x1="${margin.left}" y1="${margin.top + plotHeight}" x2="${margin.left + plotWidth}" y2="${margin.top + plotHeight}" stroke="var(--text-muted)" stroke-width="1"/>
        <line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${margin.top + plotHeight}" stroke="var(--text-muted)" stroke-width="1"/>
      `;

      // X-axis ticks
      [44, 48, 52, 56, 60].forEach(v => {
        const x = scaleX(v);
        svgContent += `<text x="${x}" y="${margin.top + plotHeight + 20}" fill="var(--text-muted)" font-size="10" text-anchor="middle">${v}%</text>`;
      });

      // Y-axis ticks
      [-15, -10, -5, 0, 5, 10, 15].forEach(v => {
        const y = scaleY(v);
        svgContent += `<text x="${margin.left - 10}" y="${y + 3}" fill="var(--text-muted)" font-size="10" text-anchor="end">${v > 0 ? '+' : ''}${v}</text>`;
      });

      // Axis labels
      svgContent += `
        <text x="${width / 2}" y="${height - 8}" fill="var(--text-secondary)" font-size="12" font-weight="500" text-anchor="middle">HDCF% (High-Danger Chances For)</text>
        <text x="18" y="${height / 2}" fill="var(--text-secondary)" font-size="12" font-weight="500" text-anchor="middle" transform="rotate(-90, 18, ${height / 2})">xG Differential</text>
      `;

      // Plot teams
      processedTeams.forEach(team => {
        const x = scaleX(team.hdcf);
        const y = scaleY(team.xgd);
        const baseSize = 20;
        const formBonus = team.formStatus === 'hot' ? 6 : team.formStatus === 'warm' ? 2 : team.formStatus === 'cold' ? -2 : team.formStatus === 'freezing' ? -4 : 0;
        const size = Math.max(14, baseSize + formBonus);

        svgContent += `
          <g class="team-dot" data-team="${team.team}" style="cursor: pointer">
            <circle cx="${x}" cy="${y}" r="${size}" fill="${getTierColor(team.tier)}" fill-opacity="0.85" stroke="var(--text-primary)" stroke-width="1"/>
            <text x="${x}" y="${y + 3}" fill="white" font-size="8" font-weight="700" text-anchor="middle">${team.team}</text>
          </g>
        `;
      });

      svg.innerHTML = svgContent;

      // Add hover events
      const tooltip = document.getElementById('tooltip');
      svg.querySelectorAll('.team-dot').forEach(dot => {
        const teamAbbr = dot.dataset.team;
        const team = processedTeams.find(t => t.team === teamAbbr);

        dot.addEventListener('mouseenter', (e) => {
          tooltip.innerHTML = `
            <div class="tooltip-name" style="color: ${getTierColor(team.tier)}">${team.name}</div>
            <span class="form-badge ${getFormClass(team.formStatus)}">${getFormIcon(team.formStatus)} ${team.formStatus.toUpperCase()}</span>
            <div class="tooltip-grid">
              <div class="tooltip-row"><span class="tooltip-label">Score:</span><span class="tooltip-value" style="color: ${getTierColor(team.tier)}">${team.score}</span></div>
              <div class="tooltip-row"><span class="tooltip-label">HDCF%:</span><span class="tooltip-value">${team.hdcf.toFixed(1)}%</span></div>
              <div class="tooltip-row"><span class="tooltip-label">xG Diff:</span><span class="tooltip-value" style="color: ${team.xgd > 0 ? 'var(--accent-elite)' : 'var(--accent-longshot)'}">${team.xgd > 0 ? '+' : ''}${team.xgd.toFixed(1)}</span></div>
              <div class="tooltip-row"><span class="tooltip-label">Record:</span><span class="tooltip-value">${team.w}-${team.l}-${team.otl} (${team.pts}pts)</span></div>
              <div class="tooltip-row"><span class="tooltip-label">GSAx:</span><span class="tooltip-value" style="color: ${team.gsax > 0 ? 'var(--accent-purple)' : 'var(--text-secondary)'}">${team.gsax > 0 ? '+' : ''}${team.gsax.toFixed(1)}</span></div>
            </div>
          `;
          tooltip.style.top = (e.clientY - 100) + 'px';
          tooltip.style.right = '30px';
          tooltip.style.left = 'auto';
          tooltip.style.borderColor = getTierColor(team.tier);
          tooltip.classList.add('visible');
        });

        dot.addEventListener('mouseleave', () => {
          tooltip.classList.remove('visible');
        });
      });
    }

    function renderPlayoffs() {
      const grid = document.getElementById('playoffs-grid');
      const hasPredictions = Object.keys(modelPredictions).length > 0;

      if (!hasPredictions) {
        grid.innerHTML = '<div style="text-align: center; padding: 2rem; color: var(--text-muted);">Model predictions unavailable. Ensure dashboard_data.json is present.</div>';
        return;
      }

      grid.innerHTML = ['East', 'West'].map(conf => {
        const confTeams = processedTeams
          .filter(t => t.conf === conf)
          .sort((a, b) => {
            const aP = modelPredictions[a.team];
            const bP = modelPredictions[b.team];
            return (bP?.cupProbability || 0) - (aP?.cupProbability || 0);
          });

        return `
          <div class="conf-section">
            <h3>${conf}ern Conference</h3>
            <table class="playoffs-table">
              <thead>
                <tr>
                  <th>Team</th>
                  <th>Tier</th>
                  <th>Strength</th>
                  <th style="color: var(--accent-elite)">
                    Playoff %
                  </th>
                  <th style="color: #fbbf24; font-weight: 700">
                    Cup %
                    <span class="ci-tooltip ci-info-icon" data-tooltip="95% confidence interval shown below">?</span>
                  </th>
                  <th>Pts</th>
                </tr>
              </thead>
              <tbody>
                ${confTeams.map((team, idx) => {
                  const pred = modelPredictions[team.team] || {};
                  const playoffPct = pred.playoffProbability || 0;
                  const cupPct = pred.cupProbability || 0;
                  const cupLo = pred.cupProbLower || cupPct;
                  const cupHi = pred.cupProbUpper || cupPct;
                  const tier = pred.tier || 'Longshot';
                  const strength = pred.compositeStrength || 0;
                  const tierColor = pred.tierColor || '#ef4444';
                  const pctClass = playoffPct >= 90 ? 'pct-high' : playoffPct >= 50 ? 'pct-mid' : 'pct-low';
                  const cupMargin = ((cupHi - cupLo) / 2).toFixed(2);
                  return `
                    <tr class="${playoffPct >= 50 ? 'playoff-in' : 'playoff-out'}">
                      <td>
                        ${team.team}
                        <span style="color: var(--text-muted); font-size: 0.65rem; margin-left: 4px">(${team.div})</span>
                      </td>
                      <td style="color: ${tierColor}; font-weight: 600; font-size: 0.75rem">${tier}</td>
                      <td style="font-weight: 600">${strength.toFixed ? strength.toFixed(1) : strength}</td>
                      <td>
                        <span class="playoff-pct ${pctClass}" style="--pct: ${playoffPct}%">${playoffPct}%</span>
                      </td>
                      <td>
                        <div class="ci-display">
                          <span style="color: ${cupPct >= 10 ? '#fbbf24' : cupPct >= 3 ? '#f59e0b' : 'var(--text-muted)'}; font-weight: 700">${cupPct}%</span>
                          <span class="ci-range ci-tooltip" data-tooltip="95% CI: ${cupLo}% - ${cupHi}%">${hasPredictions ? 'Â±' + cupMargin + '%' : ''}</span>
                        </div>
                      </td>
                      <td style="color: var(--text-muted)">${team.pts}</td>
                    </tr>
                  `;
                }).join('')}
              </tbody>
            </table>
          </div>
        `;
      }).join('');
    }

    function renderWeights() {
      const tbody = document.getElementById('weights-body');
      tbody.innerHTML = WEIGHTS_INFO.map(w => `
        <tr class="${w.isNew ? 'weight-new' : w.reduced ? 'weight-reduced' : ''}">
          <td class="${w.isNew ? 'factor-new' : w.reduced ? 'factor-reduced' : ''}" style="font-weight: 600">
            ${w.isNew ? 'âœ¨ ' : ''}${w.factor}
          </td>
          <td>${w.weight}%</td>
          <td>${w.note}</td>
        </tr>
      `).join('');
    }

    // Event handlers
    document.querySelectorAll('.nav-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentView = btn.dataset.view;

        document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
        document.getElementById(currentView + '-view').classList.add('active');

        if (currentView === 'scatter') renderScatter();
        if (currentView === 'playoffs') renderPlayoffs();
        if (currentView === 'weights') renderWeights();
      });
    });

    document.querySelectorAll('.conf-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.conf-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentConf = btn.dataset.conf;
        renderMatrix();
      });
    });

    // V7.0: Dynamic data loading from JSON (with hardcoded fallback)
    let dataLastUpdated = null;

    async function loadTeamData() {
      try {
        const response = await fetch('data/teams.json');
        if (!response.ok) throw new Error('Failed to fetch');

        const data = await response.json();

        if (data.teams && data.teams.length > 0) {
          // Map JSON data to match expected format
          teamsData = data.teams.map(t => ({
            team: t.team,
            name: t.name || t.team,
            conf: t.conf || 'East',
            div: t.div || '',
            gp: t.gp || 0,
            w: t.w || 0,
            l: t.l || 0,
            otl: t.otl || 0,
            pts: t.pts || 0,
            gf: t.gf || 0,
            ga: t.ga || 0,
            cf: t.cfPct || t.cf || 50,
            hdcf: t.hdcfPct || t.hdcf || 50,
            pdo: t.pdo || 100,
            xgf: t.xgfPct || t.xgf || 50,
            xga: 100 - (t.xgfPct || 50),
            recentXgf: t.recentXgf || t.recentPts || 50,
            pkPct: t.pkPct || 80,
            ppPct: t.ppPct || 20,
            weight: t.weight || 200,
            hasStar: t.hasStar || false,
            depth20g: t.depth20g || 3,
            gsax: t.gsax || 0,
            goalieSvPct: t.goalieSvPct || 0.910,
            starPPG: t.starPPG || 0,
            playoffExp: t.playoffExp || {},
            hdSavePct: t.hdSavePct,
            oneGoalRecord: t.oneGoalRecord,
            coachScore: t.coachScore,
          }));

          // Update last updated timestamp
          if (data._metadata?.generatedAt) {
            dataLastUpdated = new Date(data._metadata.generatedAt);
            const updateEl = document.querySelector('.data-source');
            if (updateEl) {
              const dateStr = dataLastUpdated.toLocaleDateString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit'
              });
              updateEl.innerHTML = `Data auto-updated: ${dateStr} | <a href="https://naturalstattrick.com/teamtable.php" target="_blank">Natural Stat Trick</a> | <span style="color: var(--accent-elite)">V7.3 Superhuman Model</span>`;
            }
          }

          console.log(`Loaded ${teamsData.length} teams from JSON`);
        }
      } catch (error) {
        console.log('Using hardcoded team data (JSON fetch failed or not available):', error.message);
      }

      // Load superhuman model predictions
      try {
        const modelResponse = await fetch('dashboard_data.json');
        if (modelResponse.ok) {
          const modelData = await modelResponse.json();
          if (modelData.teams && modelData.teams.length > 0) {
            modelData.teams.forEach(t => {
              modelPredictions[t.code] = t;
            });
            console.log(`Loaded superhuman predictions for ${Object.keys(modelPredictions).length} teams`);
          }
        }
      } catch (error) {
        console.log('Superhuman model predictions not available:', error.message);
      }

      // Render after data is ready (either loaded or fallback)
      renderMatrix();
    }

    // Initial load
    loadTeamData();
  </script>
</body>
</html>
